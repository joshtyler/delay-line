% we want fancy headers (top matter might have changed that)
%\pagestyle{fancy}

\chapter{\chapterStyle{Introduction}} \label{sec:intro}
\gls{tnmoc} is currently hosting a project to reconstruct a very early computer: \gls{edsac}. The exact nature of the machine will be discussed in Chapter \ref{sec:tech-rev}, however it should be noted that the recreation of its memory is non trivial, and the design of this subsystem is the focus of this project.

The reconstruction effort has made good progress towards recreating the machine, and is already developing a separate solution to the memory problem. The history of \gls{edsac}, along with the technical details of how its memory functions is summarised in Chapter \ref{sec:tech-rev}. The final section in this chapter uses the technical background derived to describe the exact aims of this project, explaining why it is important and comparing the goal of this project to the solution currently being developed by the reconstruction project. Utilising the technical details of the review, Chapter \ref{sec:spec} then derives a specification to establish the required performance of the memory solution in explicit detail.

Working from the specification derived in Chapter \ref{sec:spec}, Chapter \ref{sec:power} contains the design details of how the solution is powered, whilst Chapter \ref{sec:delay-line-des} details the design decisions taken in the creation of the memory mechanism itself.

Given that \gls{tnmoc} is located in Bletchley, and the project is created in Southampton, it has been necessary to produce a method of testing the memory solution which does not rely upon any of the hardware produced by the reconstruction project. For this reason, Chapter \ref{sec:test-harness-design} details the design of a test harness which is capable of testing the memory by emulating the signals produced by \gls{edsac}.

The memory solution interfaces with valve circuitry that comprises the remainder of \gls{edsac}. Parts of this circuitry are very sensitive, and so to ensure that this project would not have any unintended parasitic effects on \gls{edsac} \gls{spice} simulations are used to model the impact this project would have on the circuitry of \gls{edsac}. This is detailed in Chapter \ref{sec:verification}, alongside details of how the digital circuitry of the memory solution is verified.

Following the design and implementation stages, all of the components of the memory module and test harness have been integrated and tested. This, along with details of problems encountered and how they were rectified are described in Chapter \ref{sec:sys-integration}.

The scope encompassed by this project has demanded careful time planning, and analysis of any risks that could derail the goals of the project. This is detailed in Chapter \ref{sec:project-planning}. Final comments comparing the aims of the project to the outcomes, and an outline of scope for future work, are then presented in Chapter \ref{sec:conclusion}.

\chapter{\chapterStyle{Technology Review}} \label{sec:tech-rev}
This chapter presents an overview of \gls{edsac}, and an overview of the relevant literature surrounding its memory architecture. It should be noted that much of the literature presented comes from original documentation produced by Maurice Wilkes, the man who led the original \gls{edsac} project. This is because, despite the notability of \gls{edsac}, its architecture was quickly adapted to develop other machines. Therefore, aside from the papers written by Wilkes himself, there is little technical documentation from other sources of the machine in its original state.

\section{\glsentryshort{edsac} overview} \label{sec:edsac-overview}
\Gls{edsac}, pictured with two of its creators in Figure \ref{fig:edsac-photo} \cite{cam2011}, was the first practical digital stored program computer. This means that it was the first practical computer able to accept a program from the user, store it in memory, and execute it on the fly. In contrast to this, earlier computers such as \gls{eniac}, hard-coded programs using switches. In the case of \gls{eniac} using 3,600 10-way switches \cite{cruz2013}. The only digital stored program computer earlier than \gls{edsac} was the Manchester small-scale experimental machine. This machine was not intended for general purpose computation however, but rather for testing of a new type of memory \cite{jones2001}.

The goal of the reconstruction project at \gls{tnmoc} is to reconstruct the computer as faithfully as possible to its state when it ran its first ever program in May 1949 \cite{nmoc2017}.


\begin{figure}[ht]
	\centering
	\includegraphicssized{wilkes_renwick_edsac_crop}
	\caption{W.Renwick and M.Wilkes standing with \glsentryshort{edsac} \cite{cam2011b}}
	\label{fig:edsac-photo}
\end{figure}

\section{\glsentryshort{edsac} Memory Architecture} \label{sec:edsac-mem-arch}
The completion of \gls{edsac} in 1949 posed a significant design challenge for the memory of the machine. Transistors were not commercially available at all until 1951 \cite{bonne2007}, and valves, whilst available, were physically large, and fairly expensive. This meant that creation of even a modest amount of storage would not have been feasible. \Gls{eniac} used valves, but also had very little memory. This was not a problem for its intended application, but would have posed a problem for a general purpose computing platform, such as \gls{edsac} \cite[p.208]{wilkes1948}.

The solution chosen for \gls{edsac}'s storage problem was delay line memory. This was common with other early computers, and works via a fairly simple mechanism. Given a medium able to delay a pulse train by a certain amount, memory can be created by feeding the output of that delay medium back into the input. If the delay time is tuned to be an integer multiple of the system clock frequency, the system is able to store a sequence of bits proportional in length to the delay time. This principle is illustrated in Figure \ref{fig:delay-line-principle}.

Delay lines exist in various forms, from magneto-restrictive delay lines which function by twisting one end of a coil of wire, then waiting for the stress to propagate to the other end of the wire, to electric delay lines which provide much smaller delays by sending electrical impulses down a length of coaxial wire or a \gls{pcb} micro-strip trace.

\begin{figure}[ht]
	\centering
	
	\begin{tikzpicture}[node distance=\nodeDist, every node/.style={transform shape}]
	
	
	\node (delay) [block, anchor=south west, minimum width=5*\nodeDist] at (0,0) {Delay Unit};
	
	\node (gate) [block, below=of delay.south west, anchor=north west] {Gate};
	
	\node (amp) [block, below=of delay.south east, anchor=north east] {Amplifier};
	
	\draw [arrowNml] (gate.west) -- ++(-0.5*\nodeDist,0) |- (delay.west);
	
	\draw [arrowNml] (delay.east) -- ++(0.5*\nodeDist,0) |- (amp.east);
	
	\draw [arrowNml] ([yshift=0.25*\nodeDist] amp.west) -- ([yshift=0.25*\nodeDist] gate.east);
	
	\draw [arrowRev] ([yshift=-0.25*\nodeDist] gate.east) -- ++(\nodeDist,0) -- ++(0,-\nodeDist) -- ++(-0.5*\nodeDist,0) node[left] {Clock Pulses};
	
	
	\end{tikzpicture}
	
	\caption{Demonstration of the principle of delay line memory, adapted from \cite{tyler2017}}
	\label{fig:delay-line-principle}
\end{figure}


\Gls{edsac} used acoustic delay lines in the form of steel tubes full of mercury. Impulses were inserted into one end of the tube via a quartz transducer, and reach the other end of the tube after a delay proportional to the length of the tube. Here a second quartz transducer converts the incoming acoustic impulse into an electronic impulse \cite[p.209]{wilkes1948}.


These delay lines are used in two ways \cite[p.213]{wilkes1948}:
\begin{enumerate}
	\item Short tubes used for the results of calculations.
	\item Batteries of longer tubes used as the main memory store, illustrated in Figure \ref{fig:coffins}.
\end{enumerate}


\begin{figure}[ht]
	\centering
	\includegraphicssized{delay_lines}
	\caption{A battery of mercury delay lines in \glsentryshort{edsac} \cite{cam2011c}}
	\label{fig:coffins}
\end{figure}

\Gls{edsac} stores words in units of 36 pulses, which is referred to as a minor cycle. 34 pulses are used to store the magnitude of a number, one stores the sign, and one acts as a space between numbers. This system was chosen to allow storage of ten digit numbers \cite[p.209]{wilkes1948}. 

The shorter tubes are sized to store only a single minor cycle, but the longer tubes are long enough to store 576 pulses (16 minor cycles). The batteries of these tubes each contained 16 tubes, and \gls{edsac} originally had two batteries, allowing for a total storage capacity of $16 \times 16 \times 2 = 512$ numbers \cite[p.210]{wilkes1948}.

\subsection{Timing} \label{sec:review-delay-timing}
The memory in \gls{edsac} uses a circulating bit rate of \SI{500}{\kilo\hertz}. This is made up of a \SI{0.9}{\micro\second} pulse, and a \SI{1.0}{\micro\second} gap for each bit, although some literature specifies a pulse of \SI{0.9}{\micro\second} and a gap of  \SI{1.0}{\micro\second}, implying a \SI{526}{\kilo\hertz} bit rate \cite[p.209]{wilkes1948} \cite[p.2]{cambridge1948}. The pulse is a burst of \SI{13.5}{\mega\hertz} carrier frequency if the bit is a logical 1, or it is 0V if the bit is a logical 0 \cite[p.2]{cambridge1948}.

It should be noted that the original machine rarely ran at this exact frequency, and the clock frequency was actually adjusted with temperature. The reason for this is that the acoustic delay though mercury varies enough over the normal temperature range of a laboratory environment to cause the memory to fall out of sync with the system clock. To combat this, the original clock frequency was adjusted with temperature to re-synchronise the system. Later in the life of \gls{edsac} this solution was deemed unsatisfactory and the coffins were enclosed in a temperature controlled environment \cite[p.81]{wilkes1952}.

To allow consistent operation of the machine, it is desirable that the recreated \gls{edsac} does not emulate this variation of delay dependant upon temperature, but the delay of each line should be tunable around the nominal delay given by Equation \ref{eq:nom-delay}.

\newcommand{\nominalLongTubeDelayMs}{1.15}

\begin{equation}
	D = \frac{1}{\SI{500}{\kilo\hertz}} \times 576 = \SI{\nominalLongTubeDelayMs}{\milli\second}  \label{eq:nom-delay}
\end{equation}


In the regeneration portion of the circuitry, the pulses are demodulated from the \SI{13.5}{\mega\hertz} carrier and stretched to approximately \SI{1.9}{\micro\second} long, just long enough that each pulse fails to overlap its neighbour \cite[p.212]{wilkes1948}. The demodulated pulse then is passed into a logical AND function with the system clock to produce the regenerated pulse. This process is illustrated in Figure \ref{fig:edsac-pulse-timing}.

\begin{figure}[ht]
	\centering
	
	\newcommand{\lowPeriodLessOne}{12.5L}
	\newcommand{\highPeriodLessOne}{12.5H}
	\newcommand{\lowPeriod}{L \lowPeriodLessOne}
	\newcommand{\highPeriod}{H \highPeriodLessOne}
	
	%Each period is 27 units long
	\newcommand{\sysClkPeriod}{\lowPeriodLessOne C \highPeriodLessOne C}
	
	\newcommand{\modulatedPulse}{12{C} C 0.5C}
	\newcommand{\gap}{; [dotted, red] \lowPeriod ;}
	
	%N.B One half is exactly 66.5 units long
	\newcommand{\lowHalf}{\lowPeriodLessOne 4{\lowPeriod}}
	
	\begin{tikztimingtable} [xscale=0.2, timing/slope=.5]
		% There are 27 13.5M periods per system clock
		System clock & 2{\sysClkPeriod} 12.5L \gap 2{\sysClkPeriod} \lowPeriodLessOne  \\
		%
		Transmitted burst & \lowPeriodLessOne \modulatedPulse 3{\lowPeriod} \gap \lowHalf \\
		%
		Received burst &  \lowHalf \gap 6.75L \modulatedPulse 6.75L 2{\lowPeriod} \lowPeriodLessOne \\
		%
		%       Period is 27 units long, Therefore 24.3units of high, plus 2.7 units of low
		Demodulated pulse &  \lowHalf \gap 6.75L 24.3H 2.7L 6.75L \lowPeriod \lowPeriodLessOne \\
		%
		Re-clocked pulse & \lowHalf \gap \lowPeriodLessOne \highPeriod 3{\lowPeriod}\\
		%
		Re-transmitted burst & \lowHalf \gap \lowPeriodLessOne \modulatedPulse 3{\lowPeriod} \\
		\extracode
		\begin{pgfonlayer}{background}
			\vertlines[gray!40]{12.5, 26, 92.5,106}%,146.5}
		\end{pgfonlayer}
	\end{tikztimingtable}
	\caption{\Glsentryshort{edsac} pulse timing }
	\label{fig:edsac-pulse-timing}
\end{figure}

This is important because it means that the pulses that have passed through a delay line are effectively resynchronised to the system clock. If the system did not work in this way, then the delay lines in the the original \gls{edsac} would never have worked. The reason for this is that if the pulse width was not expanded whilst demodulating, any minuscule difference in timing between the system clock and delay line would cause failure very quickly, as each successive regenerated pulse would be narrower than the last.

\newcommand{\maxJitterPlusSkewNs}{50} %Maximum jitter plus skew in nano seconds

The regeneration system implies that the maximum acceptable skew of the delay line from its nominal delay is $\pm\SI{500}{\nano\second}$. This does not, however, take into account other factors such as the jitter and longer term drift of the system clock, as well the slew rates of the analogue circuitry. Whilst the demodulating pulse is lengthened to \SI{1.9}{\micro\second}, it is unlikely to be consistently at its peak voltage for this time, and so the output pulse is likely to have a better shape if the delay line produces an output in the middle of this period. Therefore creating a system which is an order of magnitude better than the above calculation, i.e. a maximum deviation from the nominal value of \SI{\maxJitterPlusSkewNs}{\nano\second}, seems reasonable.

\subsection{Electrical} \label{sec:review-delay-electrical}

\newcommand{\maxDelayInputV}{35}
\newcommand{\minDelayInputV}{25}

\newcommand{\maxDelayOutputmV}{100}
\newcommand{\minDelayOutputmV}{10}


Electrically speaking, \gls{edsac} originally drove the delay lines with a nominal voltage of \SI{25}{\volt} peak to peak, through a \SI{70}{\ohm} terminated transmission line. The loss in the delay lines was \SI{68}{\decibel}, leading to an output voltage of approximately \SI{10}{\milli\volt} \cite[p.212]{wilkes1948}.

Despite this, the recreation project has discovered that the regeneration circuitry actually feeds the delay lines with a decreasing voltage as the pulses propagate through the lines. The voltage starts off at approximately \SI{\maxDelayInputV}{\volt} for a signal fed to a delay line at the start of the store, but is reduced to approximately \SI{\minDelayInputV}{\volt} for the tubes at the end of the store.

In addition to this, problems were experienced by the reconstruction project with amplifying the low signal level output by the delay lines at the \SI{10}{\milli\volt} level. Due to this, the current delay line solution outputs the delayed pulse at approximately \SI{100}{\milli\volt} peak.

\subsection{Mechanical} \label{sec:review-delay-mech}
\newcommand{\tubeLenCm}{165.5} %Tube length in cm
\newcommand{\tubeOdCm}{4.44} %Tube outer diameter in cm


The store delay lines originally consisted of banks of \SI{\tubeLenCm}{\centi\metre} long steel tubes. The tubes were then held in an array using machined end-plates \cite[p.210]{wilkes1948}. An illustration of this is shown in Figure \ref{fig:coffins}.

The exact dimensions, aside from the length, of each store tube are not explicitly stated in the available literature. However the dimensions of the short tubes are stated, with each short tube having an outer diameter of \SI{\tubeOdCm}{\centi\metre}, and an inner diameter of \SI{2.86}{\centi\metre} \cite[p. 213]{wilkes1948}. For the purposes of this project, the long tubes are therefore assumed to have similar dimensions to this.

The main restriction these dimensions place on the project is that the electronics must fit inside a tube of the correct length and outer diameter, so that the reconstructed system can be indistinguishable from the original in terms of form.

\section{Comparison with the Current Memory Solution} \label{sec:review-comparison}

Creating a faithful reproduction of the mercury delay line system used by \gls{edsac} poses many challenges. These challenges are discussed at length in \cite{tyler2017}, however a few of the most prevalent are: the expense of mercury, the health and safety implications of using mercury in a museum environment, and the technical challenges of the precise machining necessary for the steel tubes.


As a result of these challenges, the reconstruction project currently intends to use magneto-restrictive delay lines \cite{ward2011}, an example of which is illustrated in Figure \ref{fig:nickel-delay}. This technology works by having a length of nickel wire with transducers on each end which can either twist the wire, or detect a change in how the wire is twisted. The input pulses are therefore delayed by momentarily twisting the wire at one end. This impulse then travels down the wire and is detected at the other end after a delay.

\begin{figure}[ht]
	\centering
	\includegraphicssized{nickel-delay}
	\caption{A magneto-restrictive delay line used in the reconstruction project \cite{linnington2016}}
	\label{fig:nickel-delay}
\end{figure}

As discussed at length in \cite{tyler2017}, this method is non-ideal since it is: anachronistic for the time, dissimilar in appearance to the original delay lines, and dissimilar in terms of electrical interface to the original. Due to these shortcomings, it was decided to investigate the use of modern technology to emulate the original delay lines.

Emulation using modern technology means that it should be possible to create a system indistinguishable from the original in terms of appearance and electrical interface, whilst avoiding the need to the use of hazardous substances or tight machining tolerances.

The design of such a system, along with a suitable test harness to drive it, is the aim of this project. The requirements for this system are described more formally in the following chapter.

\chapter{\chapterStyle{Specification}} \label{sec:spec}

The research of Chapter \ref{sec:tech-rev} has led to the derivation of a specification for the delay line which will be produced. This specification is detailed in Table \ref{tbl:spec}.

\begin{longtable}{r  >{\raggedright}p{0.43\textwidth}  >{\raggedright}p{0.43\textwidth} }

	\caption{Delay line specification}\label{tbl:spec}\newcounter{specNo}\tabularnewline

	\toprule

	\bfseries Item & \bfseries Specification & \bfseries Justification \tabularnewline

	\midrule

	\endhead %Everything above this will be repeated on every page

	\bottomrule

	\endfoot

	
	\refstepcounter{specNo}\thespecNo\label{itm:spec-delay} & \textbf{Must} be capable of producing a delayed copy of the pulse train presented to it's input & This is the primary function of the device. \tabularnewline
	
	\refstepcounter{specNo}\thespecNo\label{itm:spec-power} & \textbf{Must} be powered from the input signal driven by \gls{edsac}, with only minimal, and non-intrusive, modifications made to \gls{edsac}. & The goal of the device is to faithfully recreate the appearance and electrical interface of \gls{edsac}, and thus large modifications such as power supply connections must be avoided. \tabularnewline
	
	\refstepcounter{specNo}\thespecNo\label{itm:spec-output-delay} & \textbf{Must} have a nominal delay of \SI{\nominalLongTubeDelayMs}{\milli\second}, adjustable by at least $\pm 10\%$. & \SI{\nominalLongTubeDelayMs}{\milli\second} is the nominal delay of a long tube, as discussed in Section \ref{sec:review-delay-timing}. An adjustable delay allows synchronisation with the system clock, with may vary. \tabularnewline
	
%	\refstepcounter{specNo}\thespecNo\label{itm:spec-temp-stab} & \textbf{Must} be able a delay that is stable across the temperature range of \review{[xx]} to \review{[xx]}. & As discussed in Section \review{[xx]} \gls{edsac} originally had delay lines which varied with temperature  \tabularnewline
	
	\refstepcounter{specNo}\thespecNo\label{itm:spec-skew-jitter} & \textbf{Must} have a maximum per burst deviation from the chosen delay of \SI{\maxJitterPlusSkewNs}{\nano\second}. & This ensures that the delay line output will be able to synchronise with the clock of \gls{edsac}. \SI{\maxJitterPlusSkewNs}{\nano\second} is the maximum deviation derived in Section \ref{sec:review-delay-timing} \tabularnewline
	
	\refstepcounter{specNo}\thespecNo\label{itm:spec-skew-input-v} & \textbf{Must} be able to interface with \gls{ac} coupled bursts of \SI{13.5}{\mega\hertz} carrier, with peak-to-peak voltages in the range of \SI{\minDelayInputV}{\volt} to \SI{\maxDelayInputV}{\volt} at the input. & This is necessary to mimic the performance of the original delay line, \SI{\minDelayInputV}{\volt} to \SI{\maxDelayInputV}{\volt} is the range derived in Section \ref{sec:review-delay-electrical}. \tabularnewline
	
	\refstepcounter{specNo}\thespecNo\label{itm:spec-skew-output-v} & \textbf{Must} be able to have an adjustable nominal output voltage in the range of \SI{\minDelayOutputmV}{\milli\volt} to \SI{\maxDelayOutputmV}{\milli\volt} peak-to-peak, driving into \SI{70}{\ohm}. & An adjustable output voltage in this range allows compatibility with both the original electrical interface, and that used by the reconstruction effort, \SI{\minDelayOutputmV}{\milli\volt} to \SI{\maxDelayOutputmV}{\milli\volt} is the range derived in Section \ref{sec:review-delay-electrical}. \tabularnewline
	
	\refstepcounter{specNo}\thespecNo\label{itm:spec-phys-size} & \textbf{Must} be encapsulated in a metal tube of \SI{\tubeOdCm}{\centi\metre} outer diameter, and \SI{\tubeLenCm}{\centi\metre} length. & This diameter allows the design to have the same appearance of the main memory store tubes of the original \gls{edsac} design, the width and diameter are discussed in \ref{sec:review-delay-mech} \tabularnewline
	
	\refstepcounter{specNo}\thespecNo\label{itm:spec-testing} & \textbf{Must} be accompanied by a testing device capable of emulating the signals produced by \gls{edsac}. & This allows the delay line to be tested separately to the reconstruction project. \tabularnewline
	
	
\end{longtable}

\chapter{\chapterStyle{Power System Design}} \label{sec:power}

This chapter discusses how the delay line is powered, something which has required significant design effort. As discussed in specification point \ref{itm:spec-power}, the delay line must be powered from the input signal. This is discussed prior to the design of the remainder of the delay line circuitry, since it is affected by the method of power.

A naive solution to power the delay line would be to attempt to harvest the power of the input pulses themselves, and store power from each pulse to power the circuitry when the line is inactive. This seems plausible because a \SI{20}{\volt} peak-to-peak input signal delivers \SI{1.5}{\watt} of power into the delay line for the time it is active, as calculated by Equation \ref{eq:power-delivered-to-load}, and in the best case the line is driven approximately half of the time.

\begin{equation}
P = \frac{V^2}{R} = \frac{10^2}{68} = \SI{1.5}{\watt} \label{eq:power-delivered-to-load}
\end{equation}

The problem with this is approach is that, in the worst case, one cannot guarantee that pulses will be delivered to the delay line with any frequency. When the store is storing all zeros, no pulses will be delivered to the delay line at all. Attempting to use this pulse to power the delay line would require the turn-on time to be very predictable, so that the delay of the first pulse could be compensated for. Unfortunately the unpredictable delay of the the supply rails reaching the correct level, coupled with the hard to predict delay of the \gls{fpga} configuring from flash memory would break the timing budget.

Clearly a different solution to this problem is required, and this is what will be discussed in this Chapter. Section \ref{sec:power-dc-offset} will discuss the initially proposed solution which turned out to be flawed after further investigation, and Section \ref{sec:power-valve-supply} discusses a slightly more complex solution that overcomes the shortcomings of the former.

\section{Power Requirement} \label{sec:power requirement}
The \gls{fpga} development board is powered using an LT3030 dual-output \gls{ldo} regulator \cite{lattice2017b}. This regulator produces a both a \SI{3.3}{\volt}, and a \SI{1.2}{\volt} rail which powers the \gls{gpio} banks, and \gls{fpga} core voltage respectively. Initial testing of the \gls{fpga} showed that the development board, without any support circuitry connected, showed a current draw of \SI{50}{\milli\ampere} from a \SI{5}{\volt} power supply. The exact voltage of the power supply does not matter however, since the use of a linear power regulator means that approximately the same amount of current will be drawn at all voltages. This current is larger than would be expected, as the Lattice power estimation tool estimated that the \gls{fpga} would draw approximately \SI{15}{\milli\ampere} for the design. Investigation of the other \glspl{ic} on the development board revealed that the remainder of the circuitry on the \gls{pcb} only accounted for an extra \SI{10}{\milli\ampere} -- \SI{15}{\milli\ampere}. Careful inspection of the evaluation board schematic revealed that both of the power supply rails were loaded with \SI{100}{\ohm} resistors, accounting for \SI{45}{\milli\ampere} of current draw, as calculated by Equation \ref{eq:current-draw}. Inspection of the LT3030 datasheet shows that the load regulation is specified for a minimum current draw of \SI{1}{\milli\ampere}. The current draw of the resistors is therefore excessive, and the current draw of the remaining components on the \gls{pcb} are sufficient to achieve satisfactory load regulation. The resistors were therefore removed and both the \SI{3.3}{\volt} and \SI{1.2}{\volt} rails were stable and at the correct voltage during normal operation.


\newcommand{\delayLineCurrentMa}{28}

The total current draw of the final design, including all of the analogue interface circuitry was measured at \SI{\delayLineCurrentMa}{\milli\ampere}.

\begin{align}
I &= \frac{V_1}{R_1} + \frac{V_2}{R_2} \nonumber \\
&= \frac{3.3}{100} + \frac{1.2}{100} \nonumber \\
&= \SI{45}{\milli\ampere} \label{eq:current-draw}
\end{align}

\section{DC Offset Solution} \label{sec:power-dc-offset}
Figure \ref{fig:store-regen-output} shows the output portion of the store regeneration schematic. The store regeneration unit is the unit responsible for transmitting pulses to the delay line, and amplifying the pulses returned by the delay line. From inspection of the output port that drives the delay line, S2 in the schematic, it can be seen that it is \gls{ac} coupled, by nature of capacitor C32. A simple solution to power the delay line would be to add a \gls{dc} offset to the output. This could be achieved as simply as adding a potential divider to the output of the store regeneration unit, stiff enough to provide a stable voltage for the delay line, a solution is illustrated in Figure \ref{fig:dc-offset}.

\begin{figure}[ht]
	\centering
	\includegraphicssized{store_regen_sch}[trim={15cm 2.75cm 0.25cm 9cm},clip] %Trim = {left lower right upper}
	\caption{Store regeneration unit output \cite{burton2014b}}
	\label{fig:store-regen-output}
\end{figure}


\begin{figure}[ht]
	\centering
	\begin{tikzpicture}
	
	\node (pulse_gen) [rectangle, draw, minimum size=1cm] {\shortstack{Pulse\\Generation}};
	
	%			to[node, t=\shortstack{Pulse\\Gen.}] ++(1,0)
	
	%			to[twoport, t=\shortstack{Pulse\\Gen.}] ++(1,0)
	
	\draw (pulse_gen.east)
	
	to[C, l=2.2nF] ++(2,0) coordinate (heater_top);
	
	
	\draw (heater_top)
	
	to[R] ++(0,-2)
	
	node[ground] {};
	
	\draw (heater_top)

	to[R] ++(0,2)
	
	node[vcc] {+250V DC};
	
	
	\draw (heater_top)
	
	to[TL, l^=Coaxial cable]  ++(4,0)
	
	coordinate (load_top);
	
	
	\draw (load_top)
	
	to[L, l_=1mH] ++(0,-2)
	
	to[R, l_=\shortstack{PSU\\load}] ++(0,-2)
	
	coordinate(load_btm);
	
	
	\draw (load_top)
	
	to[short] ++(3,0)
	
	coordinate (pulse_term_top);
	
	
	\draw (pulse_term_top)
	
	to[C, l_=2.2nF] ++(0,-2)
	
	to[R, l_=\shortstack{Pulse\\termination}] ++(0,-2)
	
	coordinate(pulse_term_btm);
	
	
	\draw (load_btm)
	
	to[short] ++(1.5,0)
	
	coordinate[ground]
	
	to[short] ++(1.5,0);
	
	
	\end{tikzpicture}
	\caption{Proposed \glsentryshort{dc} offset solution}
	\label{fig:dc-offset}
\end{figure}

This is an ideal solution in theory, since the \gls{dc} bias is trivial to add to the \gls{ac} coupled output, and can easily be separated from the \gls{hf} signal bursts inside the delay line. In addition, since all of the circuitry is powered using \gls{dc}, the biased input could be used directly, after low pass filtering to remove the \gls{hf} pulses, to power the \gls{ldo} regulator on the \gls{fpga} development board.

Unfortunately there is a problem with this solution. In order to meet modern health and safety requirements the \gls{hv} \gls{dc} supply to the store regeneration unit, which drives the delay line, uses a \SI{0}{\volt} rail which is isolated from ground, and is protected by a \gls{rcbo} \cite{passmore2015}. This means that any current returned via earth, as opposed to isolated \SI{0}{\volt} rail, will cause a fault, and the power supply will be turned off.

Despite this, the shields of the coaxial cables used for the delay lines are referenced directly to earth. In order to prevent earth leakage in this situation, since the termination of the pulse driving the return line would return a significant current to ground, substantial decoupling capacitors are added between earth and the isolated \SI{0}{\volt} rail on each regeneration chassis. This allows the \gls{ac} termination current to be returned correctly, but prevents any \gls{dc} current from being drawn. This limitation therefore precludes drawing a \gls{dc} current from the \gls{hv} \gls{dc} valve power supply.

\section{Valve Power Supply Solution} \label{sec:power-valve-supply}

Given that the \gls{dc} offset solution proposed in the previous section was not feasible, an alternative system was devised.

Inspection of the assembly instructions for the store regeneration chassis shows that the heater power supply is referenced directly to ground \cite{burton2014a}.

The heater power supply is a \SI{6.3}{\volt} \gls{rms}, \SI{50}{\hertz}, \gls{ac} supply, generated by mains transformer mounted on each chassis \cite[p.1]{mullard} \cite[p.1]{passmore2015}. In the regeneration chassis it is used to power the heaters for each valve. A typical valve used in the design draws \SI{1}{\ampere}, so the \SI{\delayLineCurrentMa}{\milli\ampere} load from the delay line will add a negligible load onto this supply \cite[p.1]{mullard}.

Since the supply is a \SI{50}{\hertz} supply, this is a frequency sufficiently far from the \SI{13.5}{\mega\hertz} pulse carrier frequency, that it is be easy to filter out with even a first order filter.

In order to couple the heater supply onto the store regeneration output, a single inductor is sufficient. The addition of this inductor is the only modification necessary to the \gls{edsac} chassis circuitry. A diagram showing the equivalent circuit of the modified circuitry is shown in Figure \ref{fig:valve-supply-equiv-cct}.

\begin{figure}[ht]
	\centering
	\begin{tikzpicture}
	
	\node (pulse_gen) [rectangle, draw, minimum size=1cm] {\shortstack{Pulse\\Generation}};
	
	%			to[node, t=\shortstack{Pulse\\Gen.}] ++(1,0)
	
	%			to[twoport, t=\shortstack{Pulse\\Gen.}] ++(1,0)
	
	\draw (pulse_gen.east)
	
	to[C, l=2.2nF] ++(2,0) coordinate (heater_top);
	
	
	\draw (heater_top)
	
	to[L, l_=1mH] ++(0,-2)
	
	to[sV, l_=\shortstack{Heater\\PSU}] ++(0,-2)
	
	coordinate(heater_btm)
	
	to[short] ++(-1,0)
	
	node[ground] {}
	
	to[short] ++(-1,0);
	
	
	\draw (heater_top)
	
	to[TL, l^=Coaxial cable]  ++(4,0)
	
	coordinate (load_top);
	
	
	\draw (load_top)
	
	to[L, l_=1mH] ++(0,-2)
	
	to[R, l_=\shortstack{PSU\\load}] ++(0,-2)
	
	coordinate(load_btm);
	
	
	\draw (load_top)
	
	to[short] ++(3,0)
	
	coordinate (pulse_term_top);
	
	
	\draw (pulse_term_top)
	
	to[C, l_=2.2nF] ++(0,-2)
	
	to[R, l_=\shortstack{Pulse\\termination}] ++(0,-2)
	
	coordinate(pulse_term_btm);
	
	
	\draw (load_btm)
	
	to[short] ++(1.5,0)
	
	coordinate[ground]
	
	to[short] ++(1.5,0);
	
	
	\end{tikzpicture}
	\caption{Proposed valve heater supply solution, equivalent circuit}
	\label{fig:valve-supply-equiv-cct}
\end{figure}


The reason that this circuitry works is that \SI{1}{\milli\henry} inductor in series with the heater power supply is a very low impedance to the \SI{50}{\hertz} heater supply. This allows the heater supply to be passed to the delay line with minimal series impedance, whilst providing a very high impedance path to the memory pulses, preventing unnecessary loading of them, as calculated by Equations \ref{eq:heater-supply-l-impedance} and \ref{eq:pulse-l-impedance}.

\begin{equation}
| Z_{L\SI{50}{\hertz}} | = 2 \pi f L = 2 \times \pi \times \SI{1}{\milli\henry} \times \SI{50}{\hertz} = \SI{0.31}{\ohm} \label{eq:heater-supply-l-impedance} 
\end{equation}

\begin{equation}
| Z_{L\SI{13.5}{\mega\hertz}} | = 2 \pi f L = 2 \times \pi \times \SI{1}{\milli\henry} \times \SI{13.5}{\mega\hertz} = \SI{85}{\kilo\ohm} \label{eq:pulse-l-impedance}
\end{equation}

In a similar manner the \SI{2.2}{\nano\farad} capacitor that is used to couple the output of the pulse generation circuitry presents a low impedance to the pulses from the pulse generation circuitry, but is sufficiently small to prevent a high impedance to the \SI{50}{\hertz} heater supply signal, which prevents it from interfering with the pulse generation circuitry, as demonstrated by Equations \ref{eq:heater-supply-c-impedance} and \ref{eq:pulse-c-impedance}.

\begin{equation}
| Z_{C\SI{50}{\hertz}} | = \frac{1}{2 \pi f C} = \frac{1}{2 \times \pi \times \SI{2.2}{\nano\farad} \times \SI{50}{\hertz}} = \SI{1.4}{\mega\ohm} \label{eq:heater-supply-c-impedance} 
\end{equation}


\begin{equation}
| Z_{C\SI{13.5}{\mega\hertz}} | = \frac{1}{2 \pi f C} = \frac{1}{2 \times \pi \times \SI{2.2}{\nano\farad} \times \SI{13.5}{\mega\hertz}} = \SI{5.4}{\ohm} \label{eq:pulse-c-impedance} 
\end{equation}

The same principle works for the termination and power supply circuitry inside the delay line, which will be discussed in more detail in Section \ref{sec:delay-line-ana-in}.

\subsection{Circuit Design} \label{sec:power-circuit}

Whilst Figure \ref{fig:valve-supply-equiv-cct} models the delay line power supply as a resistor, the reality is slightly more complex, since the \gls{ac} supply needs to be rectified in order to power the \gls{dc} circuitry. The circuit to achieve this is shown in Figure \ref{fig:delay-line-psu-sch}.

\begin{figure}[ht]
	\centering
	\includegraphicssized{schematics/delay_line}[trim={6cm 16cm 14cm 2.5cm},clip] %Trim = {left lower right upper}
	\caption{Delay line power supply schematic}
	\label{fig:delay-line-psu-sch}
\end{figure}

This circuit is a half wave rectifier. This design was chosen in preference to a full-wave rectifier because it removes the need for an isolating transformer inside of the delay line tube.

The combination of the diode, \SI{10}{\ohm} resistor, and \SI{10}{\milli\farad} capacitor act as a traditional half wave rectifier, with the diode only allowing a low impedance path for the positive half of the sine wave, the capacitor storing the voltage to provide continuous power to the load, and the resistor limiting the peak current drawn by the circuit. The addition of the inductor presents a high impedance to the \SI{13.5}{\mega\hertz} tone burst, preventing unnecessary loading on the input signal, as discussed in Section \ref{sec:power-valve-supply}.

The value of the capacitor was designed to keep the ripple of the supply to approximately \SI{0.1}{\ohm}, as illustrated by the linear approximation of Equation \ref{eq:delay-line-ripple}. \SI{10}{\milli\farad}, is the closest readily available value to the calculated \SI{12}{\milli\farad}. In reality the ripple will be much smaller than the calculated value, for two reasons:

\begin{enumerate}
	\item The current is approximately half of the originally anticipated \SI{60}{\milli\ampere} as discussed in Section \ref{sec:power requirement}.
	\item Energy will also be stored in the magnetic field of the inductor, as well as the electric field of the capacitor, which is ignored in this approximation.
\end{enumerate}

\begin{align}
I &= C \frac{dV}{dt} \nonumber \\
&\approx C \frac{\Delta V}{ \Delta t} \nonumber \\
\therefore C &\approx \frac{I \Delta t}{\Delta V} \nonumber \\
&\approx \frac{\SI{60}{\milli\ampere} \times \frac{1}{\SI{50}{\hertz}} }{\SI{0.1}{\volt}} \nonumber \\
&\approx \SI{12}{\milli\farad} \label{eq:delay-line-ripple}
\end{align}

The only additional component is the \SI{1}{\kilo\ohm} resistor. This is included in order to drain the voltage across the capacitor when the circuit is powered off, whilst only providing a small current drain of $I \approx \frac{6.3}{\SI{1}{\kilo\ohm}} \approx \SI{6.3}{\milli\ampere}$ in normal operation.

\chapter{\chapterStyle{Delay line Design}} \label{sec:delay-line-des}

This chapter describes the development of the delay line itself, covering the architectural choices made, as well as the detailed design, development and testing. The overall block diagram of the delay line is shown in Figure \ref{fig:delay-line-arch}.

The delay itself is implemented in the digital domain, with the goal of accurately emulating the original analogue domain design. This development is detailed in Section \ref{sec:delay-line-dig-des} with the surrounding analogue circuitry translates between the logic level signal signals of the digital circuit, and the input and output being discussed in Section \ref{sec:delay-line-ana}

\begin{figure}[ht]
	\centering

	\begin{tikzpicture}[node distance=\nodeDist, every node/.style={transform shape}]

	\node (psu) [block] at (0,0) {PSU};
	
	\node (frontend) [block, below= of psu] {\shortstack{Analogue\\Frontend}};
	
	\draw [arrowRev] (psu.west) -- ++(-\nodeDist,0) -- ++(0, -0.5*\nodeDist - 0.5*\blockHeight) coordinate (input_branch) -- ++(-\nodeDist,0) node[left] {Input};

	\draw [arrowNml] (input_branch) |- (frontend.west);
	
	\node (fpga) [block, right= of frontend.south east, anchor= south west, minimum height = 2*\blockHeight + \nodeDist] {\shortstack{FPGA\\Development\\Board}};
	
	\draw [arrowNml] (psu.east) -- node[above] {\shortstack{\texttildelow \SI{6}{\volt}\\\glsentryshort{dc}}} ([yshift=-0.5*\blockHeight] fpga.north west);
		
	\draw [arrowNml] (frontend.east) -- node[above] {\shortstack{\texttildelow $\SI{3}{\volt}_\text{pk}$\\Pulses}} ([yshift=0.5*\blockHeight] fpga.south west);
	
	\node (out_amp) [block, right= of fpga, minimum height = 2*\blockHeight + \nodeDist] {\shortstack{Output\\Amplifier}};
	
	\draw [arrowNml] ([yshift=-0.5*\blockHeight] fpga.north east) -- node[above] {\shortstack{\SI{3.3}{\volt}\\\glsentryshort{dc}}} ([yshift=-0.5*\blockHeight] out_amp.north west);
	
	\draw [arrowNml] ([yshift=0.5*\blockHeight] fpga.south east) -- node[above] {\shortstack{\SI{3.3}{\volt}\\Signal}} ([yshift=0.5*\blockHeight] out_amp.south west);
	
	\draw [arrowNml] (out_amp.east) -- ++(\nodeDist,0) node[right] {Output};
		
	\end{tikzpicture}

	\caption{The overall architecture of the delay line}
	\label{fig:delay-line-arch}
\end{figure}


\section{Digital Design} \label{sec:delay-line-dig-des}

The goal of the digital design is to delay the signal on its input by a certain amount. If the input signal were arbitrary, then the optimal solution would be to sample the data and clock it into a single bit wide shift register. The delay would then be given by Equation \ref{eq:naive-buffer-depth}, where $t_d$ represents the delay time, $f_s$ sampling clock frequency, and $N$ the depth of the buffer.

\begin{equation}
	t_d = \frac{1}{f_s} \times N \label{eq:naive-buffer-depth}
\end{equation}

This solution, whilst possible, requires a large number shift registers for even a modest delay. The solution can therefore be simplified by consideration of the fact that the input signal is not arbitrary, the characteristics or the signal are known from the research detailed in Section \ref{sec:review-delay-timing}. It is known that:
\begin{itemize}
	\item The signal will consist of \SI{0.9}{\micro\second} pulses of \SI{13.5}{\mega\hertz} tone.
	\item Each tone burst will be separated by \SI{1.1}{\micro\second}.
	\item Each delay line can store a maximum of 576 pulses.
\end{itemize}

Using these characteristics it can be seen that a digital delay line only needs to sample store the time at which the rising edge of an incoming pulse is received. Since the packet length and modulation frequency is fixed, this can be asserted on the line a fixed delay later.

\subsection{Architecture selection}

Various architectures could be used to implement the system described in the previous section. The three most obvious methods of implementation being:
\begin{itemize}
	\item A microcontroller design.
	\item A discrete logic design
	\item A \gls{fpga} design
\end{itemize}

Microcontrollers have the advantage of being comparatively cheap and readily available. In addition they typically have more than enough \gls{ram} available than what is required to store the array of times at which pulses arrived.

The principle disadvantage is that microcontrollers, inherently to their architecture, process data sequentially. This means that even a tight processing loop which samples the input would add a much larger amount of jitter to the input compared to a hardware solution with the same clock rate. Fortunately, however, modern microcontroller architectures, typically have a large number of peripherals embedded in the silicon, which can remove computation from the core. This combined with interrupts can provide an architecture with very predictable latency.

As an example the system could be implemented using a typical microcontroller in the \gls{arm} Cortex-M0 family. To achieve the delay, one could utilise the various timers inherent inside the microcontroller architecture. To detect an input pulse a pin change interrupt would interrupt the main execution thread, and branch to an interrupt handler. This interrupt handler would read the value of a free-running timer peripheral that increments unconditionally using microcontroller master clock. The handler would then add a fixed delay value to the counter value and appends it to a queue of timer counts held in \gls{ram}. This queue contains the values of the counter, at which the output should be asserted.

The main execution thread of the microcontroller would be responsible for configuring the free running timer to trigger a second timer peripheral once its count equals the value on the top of the queue. This second counter is connected directly to an output \gls{gpio} pin, and is clocked such that the output toggles at \SI{13.5}{\mega\hertz}.

This system can therefore meet the requirements of the delay line, with a worst case jitter of one system clock period (since the Cortex-M0 family allows for deterministic latency interrupts \cite{yiu2016}). Microcontrollers with timers capable of being configured as described above are readily available also \cite{freescale2014}.

The other two alternatives, a discrete logic system, and a \gls{fpga} based system would be similar in architecture, but differ in implementation, with the \gls{fpga} based system implementing the function using the programmable fabric of a \gls{fpga}, whereas the discrete implementation would use individual \glspl{ic}. A block diagram of the proposed architecture is shown in Figure \ref{fig:hardware-system-arch}.

The concept of this architecture is similar to that of the microcontroller based system. The difference is that in hardware implementation there isn't a processor core to set up the hardware blocks, instead each hardware block is designed to perform the correct function, and interacts with the other modules using logic signals. In addition there is no need for an external modulator, as a hardware block can be created to output the modulated \SI{13.5}{\mega\hertz} signal.

The \gls{fifo} is the centre of this system. At its input is the current value of a free-running counter, added to a fixed constant representing the required delay. This value is saved into the \gls{fifo} when the rising edge detector produces a pulse on its output.

The rising edge detector is a fairly simple hardware block that outputs a pulse for a single clock cycle when it detects a rising edge on its input. It then times out for a fixed interval, to avoid triggering on the remaining pulses in the same packet.

The output of the \gls{fifo} feeds into a comparator. This comparator compares the value on the top of the \gls{fifo} with the current value of the counter, and triggers the pulse generator when the two values are equal.

The pulse generator outputs a fixed length burst of \SI{13.5}{\mega\hertz} tone whenever it is triggered. This could be implemented simply by choosing a clock frequency that is $2^n$ times greater than \SI{13.5}{\mega\hertz}.

\begin{figure}[ht]
	\centering
	\begin{tikzpicture}[node distance=\nodeDist, every node/.style={transform shape}]
	
	\node (sync) [block, anchor=west] at (0,0) {\shortstack{Synchroniser}};
	
	\node (edge) [block, right=of sync.east, anchor=west] {\shortstack{Edge\\Detector}};
	
	\node (adder) [block, below=of edge.south, anchor=north] {\shortstack{Adder}};
	
	\node (fifo) [block, right=of adder.south east, anchor=south west, minimum height=(2*\blockHeight+\nodeDist)] {\shortstack{FIFO}};
	
	\node (comparator) [block, right=of fifo.east, anchor=west, minimum height=(2*\blockHeight+\nodeDist)] {\shortstack{Comparator}};
	
	\node (pulse) [block, right=of comparator.east, anchor=west] {\shortstack{Pulse\\Generator}};
	
	\node (ctr) [block, below=of fifo.south, anchor=north] {\shortstack{Counter}};
	
	\draw [arrowRev] (sync.west) -- node[above] {Input} ++(-1.5*\nodeDist,0);
	
	\draw [arrowNml] (sync) -- (edge);
	
	\draw [arrowNml] (edge.east) -- node[above] {\shortstack{Write\\EN}} ++(\nodeDist,0);
	
	\draw [arrowNml] (adder.east) -- node[above] {\shortstack{Write\\Data}} ++(\nodeDist,0);
	
	\draw [arrowNml] (ctr.north) -- ++(0, 0.5*\nodeDist) coordinate (ctrTop) -| (adder.south);
	
	\node[above] at (ctrTop) {Count};
	
	\draw [arrowRev] (adder.west) -- ++(-\nodeDist,0) node[left] {Delay constant};
	
	\draw [arrowNml] (ctrTop) -- ++(\nodeDist,0) |- ([yshift=0.5*\blockHeight] comparator.south west);
	
	\draw [arrowDbl] ([yshift=-0.5*\blockHeight] fifo.north east) -- node[above] {\shortstack{Read\\Port}} ([yshift=-0.5*\blockHeight] comparator.north west);
	
	\draw [arrowNml] (comparator) -- node[above] {\shortstack{EN}} (pulse);
	
	\draw [arrowNml] (pulse.east) -- node[above] {Output} ++(1.5*\nodeDist,0);
	
	\end{tikzpicture}
	\caption{Proposed architecture for a \glsentryshort{fpga} or discrete system}
	\label{fig:hardware-system-arch}
\end{figure}

The advantage of the microcontroller system over a \gls{fpga} or discrete solution is twofold. Firstly the simplicity of the physical circuit necessary. A microcontroller based design would require a \gls{ic} for the microcontroller itself, and an external crystal oscillator (although some microcontrollers do have a reduced precision internal \gls{rc} oscillator, removing the need even for this), and are generally powered from a single \SI{3.3}{\volt} supply. This is in contrast to \glspl{fpga} which typically require more than one supply rail, with extensive decoupling, and a discrete solution which would require many \glspl{ic}.

Secondly a microcontroller design would likely be slightly cheaper than a discrete logic design, as low end microcontrollers are typically only slightly more expensive than individual logic \glspl{ic}, and are much less costly than typical \glspl{fpga}.

Despite these advantages, a hardware solution does have the advantage of elegance. While it has been demonstrated above that a microcontroller solution could achieve single cycle jitter, the same as a hardware solution, it is a lot more difficult to implement and verify. This is due to the fact that configuration of many hardware peripherals are required.

In addition, the cost advantage of the microcontroller solution may be smaller than is typical when comparing microcontroller and \gls{fpga} based systems. This is because the simplicity of the hardware solution would only require a very small \gls{fpga}, which may be competitive in price to a microcontroller. Alternatively a \gls{cpld} with an external \gls{ram} \gls{ic} could be used. A \gls{fpga} solution would be preferred to a discrete implementation, due to the ease of testing, and reconfiguring the hardware if the requirements change.

Therefore on balance it has been decided to proceed with a \gls{fpga} based solution.

\subsubsection{\Glsentryshort{fpga} Selection}

The primary requirements for the \gls{fpga} are as described in Table \ref{tbl:fpga-reqs}.


\newcommand{\minFpgaClkMhz}{20}
\begin{table}[ht]
	\centering
	\newcounter{FpgaSpecNo}
	
	\caption{\Glsentryshort{fpga} Requirements}

	\label{tbl:fpga-reqs}
	\begin{tabular}{l p{0.4\textwidth} p{0.4\textwidth}}

		\toprule

		Number & Requirement & Justification \\

		
		\midrule

		\refstepcounter{FpgaSpecNo}\theFpgaSpecNo\label{itm:fpga-spec-cost} &
		\textbf{Must} have a moderately low cost. &
		Using the \gls{ic} for every delay line in the store must not be cost prohibitive.\\
		
		
		\midrule
		
		\refstepcounter{FpgaSpecNo}\theFpgaSpecNo\label{itm:fpga-spec-les} &
		\textbf{Must} have enough logic elements and block \gls{ram} to implement a single long delay line. &
		This is the proposed function of the delay line.\\
		
		\midrule

		\refstepcounter{FpgaSpecNo}\theFpgaSpecNo\label{itm:fpga-spec-speed} &
		\textbf{Must} have fabric capable of being clocked fast enough to implement the design with a clock rate of greater than \SI{\minFpgaClkMhz}{\mega\hertz}. &
		System specification point \ref{itm:spec-skew-jitter} states that the maximum deviation from the chosen delay value is \SI{\maxJitterPlusSkewNs}{\nano\second}. Achieving this requires that the signal is sampled at a rate faster than $\frac{1}{\SI{\maxJitterPlusSkewNs}{\nano\second}}=\SI{\minFpgaClkMhz}{\mega\hertz}$.\\
		
		\midrule

		\refstepcounter{FpgaSpecNo}\theFpgaSpecNo\label{itm:fpga-spec-dev-board} &
		\textbf{Should} have a development board available with a width less than \SI{3.3}{\centi\metre}. &
		System specification point \ref{itm:spec-phys-size} states that the external diameter of the tube is \SI{\tubeOdCm}{\centi\metre}. Therefore assuming that the inner diameter is equal to three quarters of the outer diameter, this is the maximum diameter of board which would fit inside the tube. It would be therefore be ideal if the development board could fit inside the tube, to save a custom \gls{pcb} being designed.\\

		
		\midrule

		\refstepcounter{FpgaSpecNo}\theFpgaSpecNo\label{itm:fpga-spec-pll} &
		\textbf{Should} have a \gls{pll} to enable to fabric clock to be generated from a crystal oscillator. &
		An internal \gls{pll} is ideal, but an external \gls{pll} could also be used.\\
		
		\bottomrule

	\end{tabular}

\end{table}

At the time of writing the least expensive \gls{fpga} available from component supplier Farnell, is the a 1280 logic cell variant of the iCE40 \gls{fpga} family, produced by Lattice \cite{farnell2017}. This is \pounds5.10 in single quantity, and significantly lower in higher quantities, which is low cost enough that it could reasonably be used to replace all of the delay lines, thus meeting specification point \ref{itm:fpga-spec-cost}.

This \gls{fpga} has 1280 \glspl{lc}, which should be plenty to implement the simple design, given that each \gls{lc} in this architecture consists of a four input \gls{lut}, and a flip-flop \cite[p.2-2]{lattice2017a}. The \gls{fpga} also has \SI{64}{\kilo\bit} of block \gls{ram}. This meets specification point \ref{itm:fpga-spec-les}, when one considers that is enough to store a clock sample for each of the 576 possible pulses, even if a \SI{64}{\bit} clock width was used, as demonstrated by Equation \ref{eq:bram-size-estimate}, where $S$ represents the size of memory required. In addition to this, there is one \gls{pll} available on the \gls{fpga} die, meeting specification point \ref{itm:fpga-spec-pll}.

\begin{equation}
	S = \SI{64}{\bit} \times 576 = \SI{36}{\kilo\bit} \label{eq:bram-size-estimate}
\end{equation}

It is hard to estimate how fast a design will be able to operate in a \gls{fpga} without synthesising it, and running timing analysis. Despite this, we can estimate that the \gls{fpga} will easily meet timing at \SI{\minFpgaClkMhz}{\mega\hertz}, thus meeting specification point \ref{itm:fpga-spec-speed}, given that the register-to-register performance of the fabric is as good as \SI{403}{\mega\hertz} for a dual-port \gls{ram}, \SI{305}{\mega\hertz} for a 16:1 multiplexer, and \SI{105}{\mega\hertz} for a \SI{64}{\bit} counter.

In addition to this, a development board is available which is very narrow \cite{lattice2017b}. The exact dimensions are not provided, but it is barely wider than the \SI{22}{\milli\metre} \gls{tqfp} of the \gls{fpga} itself \cite[p.2]{lattice2017b}, meaning it is highly likely to fit in the tube, thus meeting specification point \ref{itm:fpga-spec-dev-board}.

Based upon this analysis against specification, it was decided to implement the design using the Lattice iCEstick evaluation board, with the possibility of moving to a custom \gls{pcb} if many instances of the design were required.

\subsection{\glsentryshort{hdl} Design}

Uniquely, the Lattice iCE40 family of \glspl{fpga} has an open-source toolchain available, named Project IceStorm \cite{icestorm}, which can be used as an alternative to the toolchain provided by Lattice \cite{icestorm}. Project IceStorm synthesises Verilog natively, and Lattice's iCEcube2 toolchain synthesises both Verilog and \gls{vhdl} \cite[p.10]{lattice2017c} \cite{icestorm}. Therefore in order to maintain compatibility with both toolchains, the design will be written using Verilog. Both toolchains were trialled, and the codebase is compatible with both, however Project IceStorm was selected to produce the final design output.

The design was implemented using the structure of Figure \ref{fig:hardware-system-arch}, with the rising edge detector, \gls{fifo}, comparator, and pulse generator implemented as individual Verilog modules.

\subsubsection{Rising Edge Detector}

The rising edge detector is implemented as the state machine of Figure \ref{fig:edge-detect-sm}. In the wait state, the input is sampled on every clock edge, when it is true, meaning that a rising edge has been detected, the state machine transitions to the assert state, where the output is asserted for exactly one clock cycle, as the state machine unconditionally branches to the time-out state. In the time-out state a counter is incremented until it reaches the required limit, designed to be long enough to guarantee that the pulse has finished. At this point the state machine branches back to the wait state.

\begin{figure}[ht]

	\centering

	\begin{tikzpicture}[stateMachine]

	
	\node[initial,state] (wait) {\texttt{SM\_WAIT}};

	\node[state]         (assert) [right of=wait] {\texttt{SM\_ASSERT}};

	\node[state]         (timeout) [right of=assert] {\texttt{SM\_TIMEOUT}};

	
	\path (wait) edge[bend left] node[auto] {\texttt{in}} (assert)

	(assert) edge[bend left] node[auto] {} (timeout)
	(timeout) edge[loop above] node[auto] {\texttt{ctr != (TIMEOUT-1)}} (timeout)
	(timeout) edge[bend left] node[auto] {\texttt{ctr == (TIMEOUT-1)}} (wait)

	(wait) edge[loop above] node[auto] {\texttt{!in}} (wait);

	
	\end{tikzpicture}

	\caption{Rising edge detector state machine}

	\label{fig:edge-detect-sm}
\end{figure}

\subsubsection{\Glsentryshort{fifo}}
The \gls{fifo} is implemented using a dual port \gls{ram} block, around which logic constructs are built to handle addressing of the read and write ports.

The main part of the \gls{fifo} is the read and write address generation logic. These addresses act as pointers to the current location of the read/write word in \gls{ram}. Each address is incremented on when the \gls{fifo} it read from/written to respectively, and the address loops around to the start when it reaches the end of the \gls{ram} buffer. This `round robin' approach means that the \gls{fifo} can be read from and written to an unlimited amount of times, so long as the total number of words stored is not greater than the depth of the buffer.

In addition to the read/write address pointers, there is a counter which keeps track of the total number of words stored in the buffer. This counter is decremented if a read is requested, and incremented if a write is requested (its value does not change if both a read and a write is requested at the same time, or neither a read or write is requested). This counter is used to generate empty and full signals so that the surrounding logic knows the state of the \gls{fifo}.

\subsubsection{Comparator}
The comparator is implemented as a state machine that requests data from the \gls{fifo} and asserts the output when the counter matches the data word, as illustrated by the state transition diagram of Figure \ref{fig:comparator-sm}.

The state machine works by waiting in the \texttt{SM\_WAIT\_FOR\_DATA} until the \gls{fifo} is not empty, at this point is requests the data from the \gls{fifo} and waits in \texttt{SM\_WAIT} until the correct time to trigger the output, at which point the system transitions to \texttt{SM\_ASSERT} to trigger the output modulator before resetting.

\begin{figure}[ht]

	\centering

	\begin{tikzpicture}[stateMachine]

	
	\node[initial,state] (waitData) {\texttt{\shortstack{SM\_WAIT\\\_FOR\_DATA}}};

	\node[state]         (req) [right of=waitData] {\texttt{\shortstack{SM\_\\REQUEST}}};

	\node[state]         (wait) [right of=req] {\texttt{SM\_WAIT}};
	\node[state]         (assert) [below of=req] {\texttt{SM\_ASSERT}};

	
	\path (waitData) edge[bend left] node[above] {\texttt{!empty}} (req)

	(req) edge[bend left] node[auto] {} (wait)
	(wait) edge[loop above] node[auto] {\texttt{count != data\_in}} (wait)
	(timeout) edge[bend left] node[auto] {\texttt{count == data\_in}} (assert)
	(assert) edge[bend left] node[auto] {} (waitData)
	(waitData) edge[loop above] node[auto] {\texttt{empty}} (waitData);

	
	\end{tikzpicture}

	\caption{Comparator state machine}

	\label{fig:comparator-sm}
\end{figure}

\subsubsection{Pulse Generator}
The pulse generator is implemented as another simple state machine, illustrated by Figure \ref{fig:pulse-gen-sm}. The system remains in the \texttt{WAIT} state until the generator is enabled. Once this is true it alternates between the \texttt{HIGH} and \texttt{LOW} states transitioning when an internal counter reaches a set limit (i.e. \texttt{period\_done} is true). Once a second counter, which counts the correct number of pulses to output, reaches its limit, the system transitions back to the \texttt{WAIT} state.

\begin{figure}[ht]
	
	\centering
	
	\begin{tikzpicture}[stateMachine]


	\node[initial,state] (wait) {\texttt{WAIT}};
	
	\node[state]         (high) [right of=wait] {\texttt{HIGH}};
	
	\node[state]         (low) [right of=high] {\texttt{LOW}};
	
	
	\path (wait) edge[bend left] node[auto] {\texttt{en}} (high)
	
	(high) edge[loop above] node[auto] {\texttt{!period\_done}} (high)
	
	(high) edge[bend left] node[auto] {\texttt{period\_done}} (low)
	
	(low) edge[loop above] node[auto] {\texttt{!period\_done}} (low)
	
	(low) edge[bend left=60] node[auto] {\texttt{\shortstack{period\_done AND pulse\_done}}} (wait)
	
	(low) edge[bend left] node[auto, xshift=-1cm] {\texttt{\shortstack{period\_done AND\\!pulse\_done}}} (high)
	
	(wait) edge[loop above] node[auto] {\texttt{!en}} (wait);
	
	
	\end{tikzpicture}
	
	\caption{Pulse generator state machine}
	
	\label{fig:pulse-gen-sm}
\end{figure}

\section{Analogue Design} \label{sec:delay-line-ana}

The \gls{fpga} communicates using \SI{3.3}{\volt} \gls{lvcmos} inputs and outputs. This is a great difference from the \SI{\minDelayInputV}{\volt} to \SI{\maxDelayInputV}{\volt} input, and \SI{\minDelayOutputmV}{\milli\volt} to \SI{\maxDelayOutputmV}{\milli\volt} output range. In addition to this, the input and outputs are \gls{ac} coupled and so require a voltage symmetrical about \SI{0}{\volt}. This section discusses the implementation of this circuitry

\subsection{Input} \label{sec:delay-line-ana-in}

The input voltage needs to be terminated with \SI{68}{\ohm}, the closest E12 preferred resistor value to \SI{70}{\ohm} and the value which is used by the remainder of the reconstruction project to terminate the transmission lines \cite{burton2014b}. In addition to this, the power system imposes a requirement to remove the \SI{50}{\hertz} power signal discussed in Chapter \ref{sec:power}.

\begin{figure}[ht]
	\centering
	\includegraphicssized{schematics/delay_line}[trim={6cm 11.75cm 11.5cm 6cm},clip] %Trim = {left lower right upper}
	\caption{Delay line input schematic}
	\label{fig:delay-line-input-sch}
\end{figure}

The schematic designed to interface the input signal to the \gls{fpga} is shown in Figure \ref{fig:delay-line-input-sch}.

The \SI{2.2}{\nano\farad} capacitor and \SI{68}{\ohm} resistor act as a low pass filter with a break frequency of \SI{1.1}{\mega\hertz}, as derived in Equation \ref{eq:delay-input-cutoff}. This correctly terminates the incoming \SI{13.5}{\mega\hertz} bursts, as well as presenting a high impedance to the \SI{50}{\hertz} power supply signal.

\begin{equation}
f_0 = \frac{1}{2\pi RC} = \frac{1}{2\pi \times \SI{68}{\ohm} \times \SI{2.2}{\nano\farad}} = \SI{1.1}{\mega\hertz} \label{eq:delay-input-cutoff}
\end{equation}

The next stage of the input circuitry is a \SI{4.7}{\kilo\ohm} potentiometer. This attenuates the input signal by an adjustable amount to provide a logic level input signal for the Schmitt trigger buffer.

The value of the potentiometer is designed such that it provides negligible loading on the input signal compared to the \SI{68}{\ohm} termination resistor. Despite this the current through it for a \SI{10}{\volt} input signal is $\frac{\SI{10}{\volt}}{\SI{4.7}{\kilo\ohm}} = \SI{2.1}{\milli\ampere}$, an order of magnitude greater than both the BAT54 diode leakage current (\SI{2}{\micro\ampere} max \cite[p.2]{vishay2013}), and the Schmitt buffer input leakage current (\SI{5}{\micro\ampere} max \cite[p.4]{diodesinc2014}).

The Schmitt trigger removes small glitches which may occur on the input so that they do not reach the \gls{fpga} input. it also helps to provide a defined \gls{lvcmos} output signal from the unclean input signal.

The BAT54 protection diodes clamp the input signal to the Schmitt buffer close to its supply rails. The are suitable for the task due to their fast recovery time, \SI{5}{\nano\second}, and low forward voltage, \SI{0.4}{\volt} at \SI{10}{\milli\ampere} \cite[p.2]{vishay2013}. Additionally their continuous forward current rating, \SI{200}{\milli\ampere} max is far greater than what can be sourced through the \SI{4.7}{\kilo\ohm} potentiometer.

\subsection{Output} \label{sec:delay-line-ana-output}

The output section of the delay line is required to drive the line with \SI{0}{\volt} when no pulse is present, and a \SI{\minDelayOutputmV}{\milli\volt} to \SI{\maxDelayOutputmV}{\milli\volt} peak-to-peak signal, centered about \SI{0}{\volt,} when no signal is present.


The biasing about \SI{0}{\volt} is achieved by \gls{ac} coupling the output of the amplification circuit. One problem which can occur from this is that, using a standard \gls{lvcmos} output, the output pin of the \gls{fpga} will be \SI{0}{\volt} when no pulse is being transmitted, and will oscillate between \SI{0}{\volt} and \SI{3.3}{\volt} when a pulse is being transmitted. This is a problem for the circuit because to correctly \gls{ac} couple the signal, the voltage at the capacitor should be half way between the two extreme values, i.e. \SI{1.65}{\volt}.

In order to solve this problem, the internal tri-state buffer capability of the \gls{fpga} is used. This is the purpose of the resistor network shown on the output of the \gls{fpga}. When the \gls{fpga} output is disabled, the two resistors between power rails pull the op-amp non-inverting input to $\SI{3.3}{\volt} \times\frac{\SI{1}{\kilo\ohm}}{\SI{2}{\kilo\ohm}} = \SI{1.65}{\volt}$. When the \gls{fpga} drives its output to \SI{3.3}{\volt}, the voltage at the op-amp is equal to $\SI{3.3}{\volt} \times\frac{\SI{1}{\kilo\ohm}}{\SI{1.5}{\kilo\ohm}} = \SI{2.2}{\volt}$, and when the \gls{fpga} drives \SI{0}{\volt}, the voltage at the op-amp will be $\SI{3.3}{\volt} \times\frac{\SI{0.5}{\kilo\ohm}}{\SI{1.5}{\kilo\ohm}} = \SI{1.1}{\volt}$. This arrangement is used, rather than having the \gls{fpga} directly drive the non-inverting input of the op-amp in order to avoid driving the op-amp into saturation, as it is powered from the same \SI{0}{\volt} to \SI{3.3}{\volt} rails as the \gls{fpga} \gls{gpio} pins.

The first stage op amp is a unity gain buffer amplifier used to drive the output into a \SI{220}{\ohm} potentiometer. This potentiometer is used to attenuate the signal to the required level from the \SI{1}{\volt} peak to peak amplitude driven by the op-amp to the required level. This also attenuates the bias point away from half way between the voltage rails. For this reason, the \gls{ac} component of the signal is re-biased onto \SI{1.65}{\volt} before buffering by the second amplifier.

The second amplifier is a second unity gain buffer, that critically has an output impedance of \SI{68}{\ohm} and \gls{ac} couples the output signal in order to remove the \gls{dc} bias.

\begin{figure}[ht]
	\centering
		\includegraphicssized{schematics/delay_line}[trim={2cm 5.5cm 10.5cm 9.75cm},clip] %Trim = {left lower right upper}
	\caption{Delay line output schematic}
	\label{fig:delay-line-output-sch}
\end{figure}

For both amplifiers in the circuit LMH6639 amplifiers are used \cite{ti2013}. This amplifier is selected because of several desirable properties. Firstly it has a \gls{gbp} of \SI{190}{\mega\hertz}, more than what is necessary to buffer the \SI{13.5}{\mega\hertz} signal with unity gain. In addition to this, unlike many high \gls{gbp} op-amps, the LMH6639 is a voltage feedback architecture simplifying design. Crucially for this application the amplifier is stable at a gain of +1, and has almost rail-to-rail performance at a single supply voltage of \SI{3}{\volt} (typical output range is \SI{75}{\milli\volt} to \SI{2.93}{\volt} driving \SI{150}{\ohm}.


\chapter{\chapterStyle{Test Harness Design}} \label{sec:test-harness-design}

The test harness is intended to serve two purposes. The first is to drive the delay line with tone bursts at the correct voltage level, and the second is to amplify the received pulses from the delay line and verify that they match what is expected.

In order to achieve this, the delay line is able to be tuned using the following parameters:
\begin{enumerate}
	\item Output pulse on and off period
	\item Number of words in store
	\item Demodulator output pulse width
	\item Modulator frequency
\end{enumerate}

In addition to setting the parameters, the test harness is able to store any number in any one of the memory locations.

In order to facilitate control of the test harness, a piece of \gls{pc} software able to interact with the test harness has been created.

Section \ref{sec:test-harness-comms} discusses the communication format used between the \gls{gui} application and the \gls{fpga}, Section \ref{sec:test-harness-dig} discusses the \gls{hdl} design of the test harness, Section \ref{sec:test-harness-sw} the design of the software interface, and Section \ref{sec:test-harness-ana} the design of the input and output amplifiers.

\section{Communication Format} \label{sec:test-harness-comms}
The \gls{pc} and test harness communicate over a \gls{uart} link. The reason for this is the ubiquity of serial interfaces inside embedded electronics, leading to readily available \gls{usb} to \gls{uart} converters with good driver support. The Lattice \gls{fpga} development boards already contain such a converter, removing the need for external hardware. In addition to this, a \gls{uart} protocol does not have a bus master, instead allowing both parties to transmit messages asynchronously across separate data channels. This allows the \gls{fpga} development board to inform the \gls{pc} of any changes in state without the \gls{pc} having to poll it.

The \gls{uart} packet format used is eight data bits, one stop bit, and no parity bits transmitted at 9600 baud. This was chosen because it is very simple to implement in the \gls{fpga}, and is also very commonly used, and widely supported.

Since the messages communicated between the \gls{pc} and \gls{fpga} are greater than eight bits in length, messages will be transmitted as eight packets, each containing eight bits of data. The first packet transmitted is a header packet indicating the type of the message being sent, and the following seven packets are the payload. The message is transmitted using little-endian format. The contents of the payload can vary across messages, and can contain multiple binary numbers. These numbers can be extracted using bit masking. Table \ref{tbl:msg-types} shows the valid test harness message types. It should be noted that the message types which echo back a received message, such as the acknowledge message, and some of the error messages necessarily omit the last byte from the incoming message, so as to obey the eight byte message size. This is not a problem, however, since the last byte of all the messages that do not echo an incoming message is guaranteed to be all zeros.


\begin{longtable}{>{\raggedright}p{0.2\textwidth}  >{\raggedright}p{0.3\textwidth} >{\raggedright}p{0.3\textwidth} }
	
	\caption{\Glsentryshort{uart} message types}\label{tbl:msg-types}\tabularnewline
	
	\toprule
	
	Message Type & Purpose & Payload Contents \tabularnewline
	
	\midrule
	
	\endhead %Everything above this will be repeated on every page
	
	\bottomrule
	
	\endfoot
		
		\texttt{received wrong num} & A message sent by the \gls{fpga} to the \gls{pc} to indicate that an incorrect number was received. & \texttt{addr} -- The address where the incorrect number was received.
		
		\texttt{data} -- the erroneous data received. \tabularnewline
		


	\texttt{replace num} & A message sent by the \gls{pc} to the \gls{fpga} to request replacement of a number in the \gls{edsac} store. & \texttt{addr} -- The address of the number to replace.
	
	\texttt{data} -- the new data. \tabularnewline
	


		\texttt{replace num done} & A message sent by the \gls{fpga} to the \gls{pc} to inform the \gls{pc} that a number has been received correctly. & \texttt{addr} -- The address of the number replaced. \texttt{data} -- the old data. \tabularnewline
		
		


\texttt{mod params} & A message sent by the \gls{pc} to the \gls{fpga} to change the parameters of the modulator. & \texttt{cycles per half period} -- The number of clock cycles per half period of the modulated signal. \tabularnewline



\texttt{demod params} & A message sent by the \gls{pc} to the \gls{fpga} to change the parameters of the demodulator. & \texttt{pulse width} -- The width that each incoming pulse should be demodulated to. \tabularnewline


\texttt{sys status} & A message sent by the \gls{pc} to the \gls{fpga} to change the status of the system. & \texttt{run} -- A boolean value that determines whether the system should run or not. \tabularnewline


\texttt{mem params} & A message sent by the \gls{pc} to the \gls{fpga} to change the parameters of the memory manager. & \texttt{no nums} -- The number of \gls{edsac} numbers in the store.

\texttt{test mode} -- Tells the system if it should output numbers as usual, or output a continuous stream of pulses for testing.

\texttt{pulse width} -- The width of the output pulse burst.

\texttt{pulse gap} -- The width of the gap between output pulse bursts. \tabularnewline


\texttt{err fifo full} & A message sent by the \gls{fpga} to the \gls{pc} to indicate that its \gls{uart} input \gls{fifo} is full. & None. \tabularnewline

		
		\texttt{err mem overrun} & A message sent by the \gls{fpga} to the \gls{pc} to indicate it missed a message from the memory manager because dealing with a \gls{uart} request took too long. & None. \tabularnewline


\texttt{err update whilst run} & A message sent by the \gls{fpga} to the \gls{pc} to indicate that the \gls{pc} attempted to send an update parameters request whilst the system was running. & \texttt{payload} -- the message which caused the error (less the final byte). \tabularnewline


\texttt{err invalid msg} & A message sent by the \gls{fpga} to the \gls{pc} to indicate that the \gls{pc} sent the \gls{fpga} a message of invalid type.& \texttt{payload} -- the message which caused the error (less the final byte). \tabularnewline


\texttt{ack} & A message sent by the \gls{fpga} to the \gls{pc} to acknowledge that a message has been received and acted upon. & \texttt{payload} -- the message which is being acknowledged (less the final byte). \tabularnewline
	
\end{longtable}

Since a large number of messages exist, manually writing header files for the software and \gls{hdl} that encode and decode the messages would be tedious and error prone. In addition it would be likely that as the formats of the messages need to be changed in future, allowing discrepancies between the software and hardware designs would be introduced. In order to eliminate this a Python script was written to automatically generate the Verilog and C++ header files necessary for the software and hardware implementation. This means that changes to the message format only need to happen in one place, and both systems can be updated automatically by regenerating the files.


\section{Digital Design} \label{sec:test-harness-dig}

The digital part of the test harness is implemented as a \gls{fpga} design. There are several reasons for this choice. Firstly, the design is largely based around on parametrised generation of output signals, and sampling of input signals. This is the type of application that lends itself to a hardware design rather than a software design. Secondly, the part of the design which would lend itself to a software application, namely communicating with the external controller is designed to be simple enough that a hardware implementation is not too cumbersome. Finally, choosing a design targeted towards a Lattice iCE40 \gls{fpga}, means that the same toolchain used to develop the delay line can be reused for the test harness.

A block diagram of the digital test harness architecture is shown in Figure \ref{fig:test-harnesss-system-arch}. At the centre of the diagram is the controller. This maintains system state, and acts on received messages and events as they occur, by polling both the memory manager and received message \gls{fifo}.

The two signal paths above the controller are the transmit and receive data paths. Both have a \gls{fifo} so that messages can be enqueued for transmission without having to wait for the \gls{uart} to finish transmitting the current message, and messages can be received faster than the controller is able to instantaneously handle them. The message assembler block waits to receive eight \gls{uart} packets, and then enqueues the assembled \SI{64}{\bit} word in the \gls{fifo}, and the message disassembler does the opposite taking a \SI{64}{\bit} word from the \gls{fifo} and transmitting it as eight separate packets using the \gls{uart} transmitter.

The demodulator block samples its input and when it receives a rising edge it outputs a pulse of the length determined by its parameters. This mimics the analogue demodulation which occurs in \gls{edsac}.

The modulator does the opposite, it contains a free running oscillator whose frequency is set by its parameters. The output of the system is then the logical AND of the memory manager output and the oscillator output.

\begin{figure}[ht]
	\centering
	\begin{tikzpicture}[node distance=\nodeDist, every node/.style={transform shape}]
	
	\newcommand{\controllerWidth}{4*\blockWidth}
	
	% Controller
	\node (cont) [block, minimum width=\controllerWidth] at (0,0) {\shortstack{Controller}};
	
	% UART RX Stuff
	\node (rx_fifo) [block, above=of cont.north west, anchor=south west] {FIFO};
	\node (msg_asm) [block, above=of rx_fifo.north, anchor=south] {\shortstack{Message\\Assembler}};
	\node (uart_rx) [block, above=of msg_asm.north, anchor=south] {\shortstack{UART\\Receiver}};
	
	\draw [arrowNml] (uart_rx) -- (msg_asm);
	\draw [arrowNml] (msg_asm) -- (rx_fifo);
	\draw [arrowNml] (rx_fifo.south) -- ++(0,-\nodeDist);
	
	% UART TX Stuff
	\node (tx_fifo) [block, above=of cont.north east, anchor=south east] {FIFO};
	\node (msg_disasm) [block, above=of tx_fifo.north, anchor=south] {\shortstack{Message\\Disasembler}};
	\node (uart_tx) [block, above=of msg_disasm.north, anchor=south] {\shortstack{UART\\Transmitter}};
	
	\draw [arrowNml] (msg_disasm) -- (uart_tx);
	\draw [arrowNml] (tx_fifo) -- (msg_disasm);
	\draw [arrowRev] (tx_fifo.south) -- ++(0,-\nodeDist);
	
	%Memory manager
	\node (mem) [block, minimum width=\controllerWidth, below = of cont] {Memory Manager};
	\draw [arrowNml] ([xshift=\blockWidth] cont.south west) -- node[left] {Parameters} ++(0,-\nodeDist);
	\draw [arrowNml] ([xshift=2*\blockWidth] cont.south west) -- node[left] {\shortstack{Replace\\Request}} ++(0,-\nodeDist);
	\draw [arrowRev] ([xshift=3*\blockWidth] cont.south west) -- node[left] {\shortstack{Update}} ++(0,-\nodeDist);
	
	%Demodulatator
	\node (demod) [block, left = of mem] {Demodulator};
	\draw [arrowNml] (cont.west) -| node[above] {Parameters} (demod);
	\draw [arrowNml] (demod) -- (mem);
	\draw [arrowRev] (demod.west) -- node[above] {Input} ++(-1.5*\nodeDist,0);
	
	%Modulatator
	\node (mod) [block, right = of mem] {Modulator};
	\draw [arrowNml] (cont.east) -| node[above] {Parameters} (mod);
	\draw [arrowNml] (mem) -- (mod);
	\draw [arrowNml] (mod.east) -- node[above] {Output} ++(1.5*\nodeDist,0);
	
	
	\end{tikzpicture}
	\caption{Proposed architecture for test harness}
	\label{fig:test-harnesss-system-arch}
\end{figure}


The most complex module in the design is the memory manager, a block diagram of which is shown in Figure \ref{fig:mem-manager-arch}. This module is responsible for transmitting pulses to the delay line, and ensuring that a pulse is received back at the correct time, or that no pulse is received when none is expected.

The transmitted pulse is regenerated by sending it directly to the output, or is replaced if a different number is being transmitted rather than recirculating the existing number.

The first stage of the memory manager is the clock generation blocks. The output clock generator uses a counter to divide the system clock and generate a \SI{500}{\kilo\hertz} clock used for the output, it additionally generates strobe signals for the rising and falling edge of the output clock. The bit counter increments using the rising edge strobe of the output clock, and keeps track of the current bit being transmitted. The word counter performs a similar purpose, but keeps track of the current word in the store which is being transmitted.

The number memory is an array that stores the expected value of each number, as well as a flag telling the system whether this is the current number, or if the store should be updated with this number. If it is a replacement number, the number is loaded into the replacement number shift register at the correct time, and the multiplexer outputs the least significant bit of the replacement number shift register, which is then shifted by the output clock, this is as opposed to normal operation where the output is simply connected to the input to regenerate the number.

The input is clocked into the received number shift register. When an entire word has been received, the contents of the shift register is compared to the corresponding number in the number memory. If the two do not agree than an error is signalled to the controller.

\begin{figure}[ht]
	\centering
	\begin{tikzpicture}[node distance=\nodeDist, every node/.style={transform shape}]
	
	% Clocking
	\node (out_clk) [block] at (0,0) {\shortstack{Output\\Clock\\Generator}};
	\node (bit_ctr) [block, right=of out_clk] {\shortstack{Bit\\Counter}};
	\node (word_ctr) [block, right=of bit_ctr] {\shortstack{Word\\Counter}};
	
	\draw[arrowRev] (out_clk.north) -- ++(0, \nodeDist) node[above] {Parameters};
	\draw[arrowRev] (word_ctr.north) -- ++(0, \nodeDist) node[above] {Parameters};
	
	% Number memory
	\node (num_mem) [block, below = of bit_ctr, minimum width=4*\blockWidth] {Number Memory};
	\draw [arrowRev] (num_mem.west) -- ++(-1.5*\nodeDist,0) coordinate (replace_req) node[left] {\shortstack{Replacement\\request}};
	
	
	%Replacement number shift register
	\node (replace_sr) [block, right = of num_mem.north east, anchor = north west, minimum height= (2*\blockHeight + \nodeDist)] {\shortstack{Replacement\\Number\\Shift\\Register}};
	\draw [arrowNml] (num_mem.east) -- node[above] {\shortstack{Load\\Num.}} ++(\nodeDist, 0);
	
	
	%Received number shift register, and checker
	\node (rec_sr) [block, below = of num_mem.south west, anchor = north west] {\shortstack{Received Number\\Shift Register}};
	\node (checker) [block, below=of num_mem.south east, anchor=north east] {Checker};
	\draw [arrowNml] (checker.south) -- ++(0,-0.5*\nodeDist) node[below] {\shortstack{Incorrect\\Number Received}};
	\draw [arrowNml] (rec_sr) -- node[below] {\shortstack{Parallel\\Out}} (checker);
	\draw [arrowRev] (checker.north) -- node[left] {\shortstack{Expected\\Number}} ++(0,\nodeDist);
	
	%Output Mux
	\node (mux) [block, below=of replace_sr] {Multiplexer};
	\draw[arrowNml] (replace_sr.south) -- node[right] {\shortstack{Shift\\Out}} (mux.north);
	
	\coordinate (in) at ([yshift=-(2*\blockHeight + 2*\nodeDist)]replace_req);
	
	\node[left] at (in) {Input};
	
	\draw [arrowNml] (in) -- ++(0.75*\nodeDist,0) coordinate(input_break) -- (mux);
	
	\draw [arrowNml] (input_break) |- node[left] {Shift in} (rec_sr.west);
	
	\draw [arrowNml] (mux.east) -- ++(1.5*\nodeDist,0) node[right] {Output};
	
	
	\end{tikzpicture}
	\caption{Proposed architecture for memory manager}
	\label{fig:mem-manager-arch}
\end{figure}

\section{Software Design}  \label{sec:test-harness-sw}

The \gls{pc} software to interact with the test harness must be capable of keeping track of the system state, sending messages to the delay line, interpreting the results, and presenting that information to the user. Initially, a command line tool was considered for this but, in order to provide a simpler user interface, it was decided to create a \gls{gui} application, shown in Figure \ref{fig:mem-gui-screenshot}. Despite this, it would be fairly simple to replace the \gls{gui} with a command line frontend, due to the object orientated nature of the design.

\begin{figure}[ht]
	\centering
	\includegraphicssized{mem_gui_screenshot}
	\caption{Screenshot of the software which interacts with the delay line}
	\label{fig:mem-gui-screenshot}
\end{figure}

The software is designed to be cross-platform and due to this it uses open-source, cross platform libraries to implement the interface to the outside world, namely the \gls{gui} framework and \gls{usb} to \gls{uart} converter. Additionally, the CMake build system is used to allow compilation on different platforms \cite{cmake2017}. The \gls{gui} is implemented using gtkmm, which is a C++ wrapper for the popular GTK+ \gls{gui} framework \cite{cumming2017}. The library used for serial communication is libftdi, which is an open-source alternative to the proprietary drivers provided by \gls{ftdi} for their \gls{usb} to \gls{uart} bridge \glspl{ic} \cite{intra2net2017}.

In order to allow for a modular design, the system is comprised of a series of classes. The central class is called \texttt{MainGui}. This class is responsible for creating the \gls{gui} and responding to human input. \texttt{main()} passes control to this class once some initialisation has been performed. This class then relies on a series of small classes which are responsible for the \gls{gui} elements of each sub-section of the display. These small classes all inherit from a virtual parent class, that provides a common interface for \texttt{MainGui} to communicate with the subclasses.

Aside from the classes relating to the operation of the \gls{gui}, there are a number of other classes which implement lower level operations of the software. \texttt{FtdiWrapper} is written to create a C++ wrapper for the, C, libftdi library. This is the class which handles setting up the serial port and the raw communication. One layer of abstraction above this is the \texttt{UartManager} class. This class maintains queues of messages to be sent to, or which have been received from, the \gls{fpga}. It is also responsible for ensuring that the \gls{fpga} acknowledges each message. Theses queues store messages as \texttt{UartMsg} objects. This is a base class which encapsulates a \gls{uart} message and provides access to the underlying data. For each message type there is a derived class that provides a function to print the various data words inside the message, as well as getter and setter functions for each field. The \texttt{UartMsg} header is automatically generated by the Python software described in Section \ref{sec:test-harness-comms}.

\texttt{StatusManager} and \texttt{MemoryManger} are also classes which handle lower-level operations. \texttt{StatusManager} keeps track of whether the system is running or not, as well as the parameters for the various \gls{fpga} modules. It also generates objects of type \texttt{UartMsg} to change the system status or parameters. \texttt{MemoryManger} manages the status of a single word of \gls{edsac} memory. It keeps the current value, sends messages to the test harness to update the value and ensures that the corresponding update messages are received. The system uses an array of these objects to keep track of the entire store.

\section{Analogue Design}  \label{sec:test-harness-ana}

Unfortunately, as discussed in Section \ref{sec:review-delay-electrical}, interfacing with the delay lines poses difficulty since the delay line needs to be driven with a very high voltage, \SI{\minDelayInputV}{\volt} to \SI{\maxDelayInputV}{\volt}, and the incoming pulse is very low amplitude, \SI{\minDelayOutputmV}{\milli\volt} to \SI{\maxDelayOutputmV}{\milli\volt}. This section discusses the amplification circuitry required to do this.

\subsection{Input}

The input to the delay line needs to be able to amplify the signal from the attenuated level output by the delay line, and present the \gls{fpga} with a \SI{0}{\volt} to \SI{3.3}{\volt} logic level signal

The circuitry to do this is relatively simple, and is illustrated in Figure \ref{fig:test-harness-input-sch}. A two stage non inverting amplifier is sufficient to amplify the incoming pulse to a voltage level suitable for the Schmitt trigger. The gain of each op-amp is adjustable in order to accommodate variation in the output voltage of the delay line.

\begin{figure}[ht]
	\centering
	\includegraphicssized{schematics/test_harness}[trim={12.25cm 13.5cm 2.5cm 2.5cm},clip] %Trim = {left lower right upper}
	\caption{Test harness input schematic}
	\label{fig:test-harness-input-sch}
\end{figure}

The LMH6639 op-amps selected for the delay line output, discussed in Section \ref{sec:delay-line-ana-output} are also suitable for this purpose. The \SI{190}{\mega\hertz} \gls{gbp} allows for a amplification of fourteen times per stage before appreciably attenuating the \SI{13.5}{\mega\hertz} carrier frequency. The limited slew rate of \SI{172}{\volt\per\micro\second} is also not a concern due to the low amplitude of both the input and output signals.

It should be noted that a gain of fourteen times per stage, meaning a total gain of 196, would amplify a \SI{10}{\milli\volt} peak to peak signal to \SI{1.96}{\volt} peak to peak. The positive portion of this would only be \SI{0.98}{\volt} peak, which is not high enough for the Schmitt trigger to detect. This is not a problem, however, since the delay line can be tested using the higher \SI{100}{\milli\volt} peak to peak signal amplitude used by the reconstruction project. If it is desirable in the future to test the lower amplitude signal then a further amplification stage can be added.

The Schmitt buffer and diodes protect from negative voltages output by the op-amp, and provide a clean signal to the \gls{fpga}, in a similar manner to the circuitry discussed in Section \ref{sec:delay-line-ana-in}.

\subsection{Output}

The output circuitry of the test harness is similar in principle to the input circuitry, but is more complex in the execution. In contrast to the amplification of the input signal, the output signal is very large in amplitude, \SI{\minDelayInputV}{\volt} to \SI{\maxDelayInputV}{\volt} peak to peak, and needs to be able to drive this into a \SI{68}{\ohm} load. This means that, when a tone burst is being transmitted, \SI{4.5}{\watt} is delivered to the load, as shown by Equation \ref{eq:test-harness-load-i}. In this equation the voltage is \SI{17.5}{\volt}, this is because the maximum output from \gls{edsac} is a \SI{35}{\volt} square wave symmetric about \SI{0}{\volt}, this is equivalent to delivering a constant voltage of \SI{17.5}{\volt} to the load.

\begin{equation}
P = \frac{V^2}{R} = \frac{17.5^2}{68} = \SI{4.5}{\watt} \label{eq:test-harness-load-i}
\end{equation}

In order to simplify implementation of the output stage, one restriction was added. It was decided that the amplifier selected would be limited to voltage rails of $\pm \SI{15}{\volt}$. This widely improves the range of op-amps available to purchase as the vast majority are not specified for voltages above \SI{30}{\volt}. This design choice does, however, mean that maximum peak to peak output voltage will be a little under \SI{30}{\volt}. This is lower than the maximum voltage driven by \gls{edsac}, but is large enough to demonstrate the principle of the delay line correctly receiving a large amplitude pulse. It is simple to reason, given the topology of the delay line input stage discussed in Section \ref{sec:delay-line-ana-in}, that if the delay line works well with lower amplitude pulses, \SI{35}{\volt} peak to peak pulses will not present a problem.

To implement the amplification circuit, there were several requirements for the amplifier. First the amplifier must have the ability to be powered from  $\pm \SI{15}{\volt}$ rails, as previously discussed. In addition, the amplifier must have a high \gls{gbp}, at least several times greater than the \SI{13.5}{\mega\hertz} carrier frequency to allow modest amplification.

Another specification required that the amplifier have a slew rate greater than \SI{810}{\volt\per\micro\second}, as calculated by Equation \ref{eq:test-harness-slew}. This equation calculates the minimum slew rate in order for the amplifier to transition from the lower output rail to the upper output rail in half a period of the modulation frequency, meaning at this slew rate a triangle wave would be output.

\begin{align}
	SR &\geq \frac{V_\text{pk-pk}}{\frac{1}{2} \times \frac{1}{f_m}}  \nonumber \\
	&\geq 2 \times V_\text{pk-pk} \times f_m  \nonumber \\
	&\geq 2 \times \SI{30}{\volt} \times \SI{13.5}{\mega\hertz}  \nonumber \\
	&\geq \SI{810}{\volt\per\micro\second} \label{eq:test-harness-slew}
\end{align}

Finally the op-amp must be able to deliver a current of at least \SI{220}{\milli\ampere}, as calculated by Equation \ref{eq:test-harness-output-i}. This equation calculates the minimum output current that the op-amp must be able to deliver assuming that two op-amps are being used in parallel to deliver a tone burst of 50\% duty cycle to the load.

\begin{align}
I &\geq \frac{1}{2} \times \frac{1}{2} \times \frac{V}{R}  \nonumber \\
&\geq \frac{1}{2} \times \frac{1}{2} \times \frac{15}{68}  \nonumber \\
&\geq \SI{110}{\milli\ampere} \label{eq:test-harness-output-i}
\end{align}

Surveying the op-amps available for purchase, the LM7372 was selected \cite{ti2014}. This op-amp is specified for $\pm \SI{15}{\volt}$ operation, has a very high slew rate of \SI{3000}{\volt\per\second}, and a \gls{gbp} of \SI{120}{\mega\hertz}. In addition to this the amplifiers have a short circuit source current of \SI{260}{\milli\ampere}, and sink current of \SI{250}{\milli\ampere} per amplifier, using a $\pm \SI{15}{\volt}$ supply, with two amplifiers present per package.

Having selected the amplifier, the circuit of Figure \ref{fig:test-harness-output-sch} was designed to drive the delay line. This amplifier is in three stages. The first stage is a passive biasing stage that presents the input to the first amplifier with \SI{0}{\volt} when nothing is being transmitted, and $\pm \SI{1.65}{\volt}$ when the tone burst is being transmitted. This first stage amplifier buffers the input signal and amplifies it with gain tunable by potentiometer.

The second stage is an output buffer which uses two parallel op-amps to buffer the signal and drive the load. The op-amps outputs are connected in parallel with a modest current sharing resistance. Ideally the series resistance on the output of each op-amp should be twice the characteristic impedance of the transmission line, as discussed in \cite{intersil2005}. This was not possible however because a series resistance of $2 \times \SI{68}{\ohm} = \SI{136}{\ohm}$ would limit the peak output voltage to slightly less than $\SI{15}{\volt} \times \frac{\SI{68}{\ohm}}{\SI{68}{\ohm} + \SI{136}{\ohm}} = \SI{5}{\volt}$, as the output op-amps saturate close to the voltage rails. Fortunately reflected pulses are not an issue in this case since the delay line only needs to detect the carrier, integrity of the pulses is not critical.

\begin{figure}[ht]
	\centering
	\includegraphicssized{schematics/test_harness}[trim={1.25cm 3.5cm 12.1cm 9.5cm},clip] %Trim = {left lower right upper}
	\caption{Test harness output schematic}
	\label{fig:test-harness-output-sch}
\end{figure}

It should be noted that despite the design containing the twin amplifier output stage, the second amplifier is disconnected in the final implementation. This is due to issues encountered with the stability of the op-amps when driving the load in parallel. This does not matter in practice since short circuit current of a single amplifier is greater than double the \SI{110}{\milli\ampere} required by Equation \ref{eq:test-harness-output-i}. With adequate heat sinking, a single amplifier can therefore drive the load. This was achieved by `dead-bug' soldering the amplifier \gls{ic} upside down to expose the heatsink pad, then attaching a high thermal mass heatsink and using cooling with a fan, illustrated in Figure \ref{fig:test-harness-heatsink}.

\begin{figure}[ht]
	\centering
	\includegraphicssized{driver-heatsink}[trim={0 1.5cm 0 0cm},clip] %Trim = {left lower right upper}
	\caption{Test harness cooling solution}
	\label{fig:test-harness-heatsink}
\end{figure}


\chapter{\chapterStyle{Simulation and Verification}} \label{sec:verification}

\section{\glsentryshort{spice} Simulation}
As well as practically building and testing the circuits, it was desirable to simulate the performance of the circuits using LTspice \cite{linear2017}. There are two main reasons for this. Firstly, building and testing the circuits practically takes a large amount of time, and involves expense of purchasing components. It was therefore desirable to limit the number of iterations of this process by first testing performance by simulation.

In addition to this, interfacing with the \gls{edsac} circuitry is difficult since it requires travel to Bletchley, and consideration of the practicalities of interfacing with high voltage valve circuitry.

This chapter presents the results of some of the various simulations which were run. Section \ref{sec:spice-valve-models} discusses the modelling of the valve circuitry used in \gls{edsac} and the remaining sections in the chapter discuss various simulations which took place.

\subsection{Valve Models} \label{sec:spice-valve-models}

In order to model the store regeneration circuitry, it was necessary to have models for the valves used in the design. Fortunately, work has been done previously to create models for the purposes of simulating \gls{edsac} circuitry \cite{linnington2015}. This work created models for the valves based both on datasheet characteristics, and practical measurement. The models produced had been previously tested with simulations of some parts of the store regeneration circuitry and were found to match practical measurements well.

\subsection{Delay Line Input Simulation}
The main \gls{spice} simulation is the simulation of \gls{edsac} output, and delay line input. This simulation is important because it models several of the concerns for integration with the rest of \gls{edsac}, namely:
\begin{itemize}
	\item Checking that the method of phantom powering does not effect the store regeneration output
	\item Checking that the phantom power circuitry works correctly
	\item Checking that the pulses are able to be detected and output to the \gls{fpga}
\end{itemize}

In order to run the simulation, first a model had to be created of the output of the store regeneration unit. To achieve this an LTspice schematic was created containing the store regeneration circuitry from test point 22 to the output. This section was chosen because the expected signal at TP22 is known from the commissioning documentation of \gls{edsac} \cite[p.7]{linnington2016b}, and so simulation from this point onwards is sufficient to model the output of the store regeneration unit.

This model was then tested and works correctly when terminated with \SI{68}{\ohm}.

The valve heater voltage was then modelled as a \SI{50}{\hertz} \gls{ac} source, and connected to the store regeneration output with the correct inductance.

Following this, both the power generation frontend and the pulse detection frontend of the delay line were added to the schematic. The pulse regeneration frontend is modelled as far as the Schmitt buffer which connects to the \gls{fpga}, and the power frontend is modelled as far as the outputs of the \gls{ldo} regulator on the \gls{fpga} development board, which is loaded with resistors that approximate the anticipated load.

Figure \ref{fig:psu-init} shows the simulation of the voltage rails start-up from \SI{0}{\volt} across the capacitor, gradually charging to just under \SI{6}{\volt}. The \gls{ldo} regulator is able to use this to generate stable \SI{3.3}{\volt} and \SI{1.2}{\volt} rails within \SI{2}{\second} from starting the \SI{50}{\hertz} generator. The green signal shows the input to the delay line, the blue signal shows the voltage input to the \gls{fpga} \gls{ldo} regulator, the red signal is the \SI{3.3}{\volt} rail, and the blue signal the \SI{1.2}{\volt} rail. It should be noted that in this simulation the store regeneration output is disconnected. This is done for simulation speed as simulating the store regeneration output also would cause the simulation to take an unmanageably long time. A simulation was run of one \SI{50}{\hertz} cycle to ensure that the store regeneration output did not pass to the power supply rail, and this did not occur.

\begin{figure}[ht]
	\centering
	\includegraphicssized{spice_sim/regen_out/psu_init}
	\caption{Voltage rail initialisation simulation}
	\label{fig:psu-init}
\end{figure}

Figure \ref{fig:fpga-input-sim} shows a simulation of a pulse burst from the store regeneration unit output, coupled onto \SI{50}{\hertz} valve heater signal. In this simulation the green signal is the output of the store regeneration unit. The red signal is the output of the store regeneration unit with the \SI{50}{\hertz} signal filtered out, and the blue signal is the output of the Schmitt trigger which is an input to the \gls{fpga}. It can be seen that the signal input to the \gls{fpga} exactly follows the positive going pulses of the modulated packet.


\begin{figure}[ht]
	\centering
	\includegraphicssized{spice_sim/regen_out/fpga_input}
	\caption{FPGA input simulation}
	\label{fig:fpga-input-sim}
\end{figure}

\subsection{Store Regeneration Input Simulation}
The purpose of simulating the input of the store regeneration unit is to ensure that biasing the store regeneration output onto the heater power supply does not allow any of the modulated carrier signal to couple into the sensitive analogue input section. The theory of why this would happen is illustrated in Figure \ref{fig:store-regen-input-sch}. Pentodes typically have a non-insignificant parasitic capacitance between their heater pins, and cathode. This would not ordinarily cause issues \SI{50}{\hertz} \gls{ac} heater supply, as even a moderately large parasitic capacitance would present a very high impedance to \SI{50}{\hertz}. If, however, there is a significant \SI{13.5}{\mega\hertz} signal present on the heater power supply, then this could cause a problem as the frontend of the store regeneration unit is very sensitive. On the original pulses of as little as \SI{10}{\milli\volt} peak to peak could be detected, as discussed in Section \ref{sec:review-delay-electrical}.

\begin{figure}[ht]
	\centering
	\begin{tikzpicture}
	
	\node (pulse_gen) [rectangle, draw, minimum size=1cm] {\shortstack{Pulse\\Generation}};
	
	%			to[node, t=\shortstack{Pulse\\Gen.}] ++(1,0)
	
	%			to[twoport, t=\shortstack{Pulse\\Gen.}] ++(1,0)
	
	\draw (pulse_gen.east)
	
	to[C, l=2.2nF] ++(2,0) coordinate (heater_top);
	
	
	\draw (heater_top)
	
	to[L, l_=1mH] ++(0,-2)
	
	coordinate(heater_mid)
	
	to[sV, l_=\shortstack{Heater\\PSU}] ++(0,-2)
	
	coordinate(heater_btm)
	
	to[short] ++(-1,0)
	
	node[ground] {}
	
	to[short] ++(-1,0);
	
	
	\draw (heater_mid)
	
	to[C, l^=\shortstack{Parasitic\\ Capacitance}] ++(4,0)
	
	node[right] {\shortstack{Valve Cathode}};
	
	
	
	\end{tikzpicture}
	\caption{Pulse coupling via heater supply circuit}
	\label{fig:store-regen-input-sch}
\end{figure}

%\subsubsection{Modification of valve model}
Figure \ref{fig:store-regen-input} shows the input portion of the store regeneration circuitry. The pentodes used here are EF54 pentodes, and the capacitance of concern is the parasitic capacitance between pins one and five of each pentode.

\begin{figure}[ht]
	\centering
	\includegraphicssized{store_regen_sch}[trim={0.5cm 12cm 16cm 0.5cm},clip] %Trim = {left lower right upper}
	\caption{Store regeneration unit input \cite{burton2014b}}
	\label{fig:store-regen-input}
\end{figure}

The first stage of simulation was to create a simulation model of the store regeneration frontend, without making any modification to the valve model. This was performed, and the valve model was created up to test point five, since the expected waveform at this point was known \cite[p.3]{linnington2016b}. This model was created in an LTspice schematic and the input was fed with the expected output waveform from the delay line, simulation showed that the observed waveform matched what was expected.

The next stage was to look at the EF54 model netlist and check if any capacitance was present between pins five and one of the model. No capacitance was present, and so the parasitic capacitance was not modelled.

The datasheet was then consulted, and it was found that the heater-cathode capacitance was not specified, however several other capacitances were, namely the input capacitance, output capacitance, anode to gate one capacitance, and gate one to gate two capacitance \cite{mullardb}. The largest of these capacitances is the input capacitance, \SI{6.2}{\pico\farad}, and the smallest is the anode to gate 1 capacitance at \SI{0.02}{\pico\farad}. Since the capacitance was not stated in the datasheet, it seems reasonable to assume that it is not largely more significant than those which are stated, and thus \SI{10}{\pico\farad} was chosen as the value to model.

In order to simulate the effect of the output coupling onto the heater voltage, a \SI{13.5}{\mega\hertz}, \SI{30}{\volt} peak-to-peak generator was connected to the heater voltage via a \SI{1}{\milli\henry} inductor, mimicking the proposed output circuit.


Figure \ref{fig:rf-disconnected} shows the result of the simulation with the \SI{13.5}{\mega\hertz} tone generator disconnected. This is the waveform which would normally be observed at test point five, and is what the modified topology should aim to match. Figure \ref{fig:rf-1mh} shows the result with the added \SI{1}{\milli\henry} inductor. Figure \ref{fig:rf-1mh} matches Figure \ref{fig:rf-disconnected} almost exactly, and so the proposed circuit works correctly.

As a test, the \SI{1}{\milli\henry} inductor used to connect the \SI{13.5}{\mega\hertz} tone generator to the output was replaced with a \SI{10}{\nano\henry} inductor. This presents a much lower impedance to the \SI{13.5}{\mega\hertz} tone, and thus one would expect the waveform at test point five to be disrupted. Figure \ref{fig:rf-10nh} shows this result, and the effect of the tone generator can clearly be seen, this demonstrates that the modified valve model works as anticipated.

\begin{figure}[ht]
	\centering
	
	\begin{subfigure}[b]{0.9\textwidth}
		\centering
		\includegraphicssized{spice_sim/regen_in/rf_disconnected}
		\caption{\SI{13.5}{\mega\hertz} output disconnected from heater}
		\label{fig:rf-disconnected}
	\end{subfigure}

	\begin{subfigure}[b]{0.9\textwidth}
		\centering
		\includegraphicssized{spice_sim/regen_in/rf_1mH}
		\caption{\SI{13.5}{\mega\hertz} output connected to heater with \SI{1}{\milli\henry} inductor}
		\label{fig:rf-1mh}
	\end{subfigure}

	\begin{subfigure}[b]{0.9\textwidth}
		\centering
		\includegraphicssized{spice_sim/regen_in/rf_10nH}
		\caption{\SI{13.5}{\mega\hertz} output connected to heater with \SI{10}{\nano\henry} inductor}
		\label{fig:rf-10nh}
	\end{subfigure}
	
	
	\caption{Store regeneration unit input simulation results}
	\label{fig:store-regen-input-sim-res}
\end{figure}

% \subsection{Delay Line Output Simulation} %Don't include this for brevity
\FloatBarrier
\section{\glsentryshort{hdl} Verification} \label{sec:hdl-verif}
Due to the lengthy iteration cycle required to synthesise a \gls{hdl} design and test it in hardware, as well as the necessity of treating a synthesised \gls{hdl} design as a black-box model, rather than being able to inspect internal signals, verification via simulation is critical.

In order to verify the designs, in the first instance a SystemVerilog testbench was written for each module, and each module was simulated using Mentor ModelSim \cite{mentor2017}. These unit-level testbenches provide stimulus to verify that each block works as anticipated before integration with the system as a whole.

The focus of the verification is, however, on system level testing, rather than extensive unit based testing. The reason for this choice is that many of the modules which make up a design are fairly simple and their functionality is trivial to verify. The majority of the problems occur during integration of the blocks at a higher level, as well as unexpected problems interfacing two modules.

SystemVerilog has been chosen as the language for verification, rather than plain Verilog which the synthesizable \gls{hdl} is implemented using. There are several reasons for this. Firstly ModelSim will be used for all of the verification in this project, so maintaining compatibility with multiple toolchains is not a concern. Secondly, SystemVerilog is a superset of Verilog, so therefore integrates well with the Verilog code. The final, and most important reason, however is that SystemVerilog includes a number of advanced simulation constructs, such as complex assertions, properties, and a number of abstract data types, that allow for simpler and more comprehensive verification.

The remainder of this section presents the verification strategies used for the delay line, and test harness. It should be noted however that the simulation waveforms are best presented in landscape format, so are presented in Appendix \ref{app:sim-wfms}.

\subsection{Delay Line Verification}

In addition to the top level delay line testbench, testbenches were written for several of the other subsystems including: the edge detector, pulse generator and \gls{fifo}. For brevity, however, these will not be discussed in this report, and the focus will be on the behaviour of the top level module.

This top-level testbench generates pulse trains representing random numbers in the same format as \gls{edsac}. The number is then transmitted as a series of modulated pulses, and each transmitted pulse burst is added to a queue with the simulation time when the pulse is expected to arrive on the delay line output. The testbench then checks the queue on each time step to verify that the system produces output bursts of the correct frequency at the correct time.
 
Figure \ref{fig:delay-sim} shows the output of this testbench. Figure \ref{fig:delay-sim-full} shows the full simulated output. The top signal is the generated by the testbench and input to the delay line, and the second signal is the output of the delay line. The output is in a high impedance state (blue) when no pulse is output, and is black when the signal is being driven. The pulses in the output signal relate exactly to a delayed version of the input pulses. This may not immediately be obvious from the simulation output image due to the image aliasing effects of having so many pulses displayed. The correct performance of the testbench is verified by the textual simulation output which displays \texttt{\# Simulation completed successfully} after the simulation run, indicating that none of the assertions failed, and each output pulse was asserted at the correct time. The lower two signals are the internal \gls{fifo} full and empty signals. It can be seen that the \gls{fifo} never entirely fills up which is the expected behaviour, and the empty signal is asserted once there are no more delayed pulses being stored in the \gls{fifo}.
 
Figure \ref{fig:delay-sim-single} shows two individual output pulses from the \gls{fifo}. The signal is high impedance when no pulse is being driven, then is a \SI{13.5}{\mega\hertz} tone burst which is the desired behaviour as discussed in Section \ref{sec:delay-line-ana-output}.

\subsection{Test Harness Verification}
To verify the test bench at a system level, a testbench was created that emulates a \gls{uart} and transmits messages to set up the test harness and transmit numbers into the delay line, which is represented by a Verilog delay in the simulated model. It can be observed whether the test harness returns the expected results.

Figure \ref{fig:harness-full} shows the results of the test harness simulation. This simulation tests configuration of the modulator, demodulator, and memory manager, starting the system, requesting that the number at address one is replaced with data three, and then requesting that the number at address one is reset to zero again.

The top signal shows the \gls{uart} messages sent from the test harness to the \gls{hdl} design, and the signal below it shows the messages returned by the \gls{fpga}, it should be noted that the \gls{uart} signal from the test harness to the design is superimposed with random noise in order to test the immunity of the \gls{uart} receiver to noise, this is the reason why there are many more transitions than would be expected shown in the simulation waveform. The two signals below this are the output to the delay line from the test harness, and delayed signal returned to the test harness. It can be seen from these two signals that a pulse is transmitted into the delay line, received, and regenerated several times before being removed, as intended.

The messages to and from the test harness are logged in the test bench output and reproduced in Figure \ref{fig:harness-sim-log}.

\begin{figure}[ht]
	\centering
	\begin{lstlisting}
# Sending 0000000000000005 at time           1000000000
# Sending 000000006c621006 at time          10333333360
# Sending 0000000000000203 at time          19666666720
# Received 000000000000050b at time          23489018149
# Sending 0000000000005104 at time          29000000080
# Sending 0000000000000005 at time          38333333440
# Received 0000006c6210060b at time          38488598149
# Sending 0000000000000105 at time          47666666800
# Received 000000000002030b at time          53488178149
# Sending 0000000000030101 at time          57000000160
# Sending 0000000000000101 at time          66333333520
# Received 000000000051040b at time          68487758149
# Received 000000000000050b at time          83487338149
# Received 000000000001050b at time          98486918149
# Received 000000000301010b at time         113486498149
# Received 0000000000000102 at time         128486078149
# Received 000000000001010b at time         143485658149
# Received 0000000000010102 at time         158485238149
	\end{lstlisting}
	\caption{Logged output of the simulation}
	\label{fig:harness-sim-log}
\end{figure}

\chapter{\chapterStyle{System Integration}} \label{sec:sys-integration}
Having developed and tested the delay line and test harness subsystems described in Chapters \ref{sec:delay-line-des} and \ref{sec:test-harness-design}, it was necessary to integrate the subsystems together and test the system as a whole. This chapter details how the subsystems were integrated mechanically, and tested at a system level. The results of this testing is presented, alongside the issues encountered in this process.

\section{Mechanical}
In order to integrate the delay line subsystems together, a metal tube of correct outer dimensions was sourced, meeting Specification Point \ref{itm:spec-phys-size}. In order for the tube to function as a standalone unit, it was necessary to deviate slightly from the original design. This is because the original tube did not have end caps, instead the delay lines were terminated with a metal plate that held all of the tubes in the `coffin', and the coaxial connectors were on the top of the `coffin'. This can be seen in Figure \ref{fig:coffins}. As a compromise end caps were machined for the delay line that cover the ends of the tube and mount the coaxial connectors perpendicular to each end cap. A photograph of the assembled delay line, whilst being tested is reproduced in Figure \ref{fig:delay-line-testing}.

\begin{figure}[ht]
	\centering
	\includegraphicssized{integration/testing}[trim={0 7.5cm 0 10cm},clip] %Trim = {left lower right upper}
	\caption{Testing the assembled delay line with the test harness}
	\label{fig:delay-line-testing}
\end{figure}

In order to mount the delay line design inside of the metal tube, the circuits described in Figure \ref{fig:delay-line-arch} were assembled on matrix board and connected to the end caps using coaxial cable. The final result of this assembly is shown in Figure \ref{fig:delay-line-assy}. In this figure, the input port is the coaxial socket at the bottom of the photo. This feeds through a short section of coaxial cable to the first matrix board. This board implements the input circuitry described in Section \ref{sec:delay-line-ana-in}, apart from the protection diodes and Schmitt buffer, as well as the power circuitry described in Section \ref{sec:power-circuit}.

From this input board two coaxial cables, one carrying the \gls{dc} power supply for the remaining circuitry, and one carrying the attenuated input signal connect to the collection of boards visible in the middle of the image. This is a stack of three boards. The lower board in the stack contains the Schmitt buffer and diode protection for the input. The middle board is the Lattice iCEstick \gls{fpga} development board, with the \gls{usb} connector, and \gls{gpio} header removed, and the top board is the analogue output circuitry. The attenuated signal is then carried from the analogue output circuitry to the output coaxial connector via coaxial cable.

\begin{figure}[ht]
	\centering
	\includegraphicssized{integration/integrated}
	\caption{The delay line assembly}
	\label{fig:delay-line-assy}
\end{figure}



\section{Issues}

During the integration stages, several issues were encountered that had not been anticipated during development. This section describes these issues, as well as how they were resolved.

\subsection{\glsentryshort{fpga} Reset Issue}
The first issue which was encountered was that when the input cable was connected the \gls{fpga} would not always configure correctly, and the output would remain in a high impedance state, irrespective of the input waveform.

The reason for this was determined to be the fact that the input power rail is brought up slowly, as the smoothing capacitor on the input was charged. Reading the programming and configuration guide for the \gls{fpga} used, it can be seen that the \gls{fpga} checks all of its supply voltages are within the correct range before it configures from the \gls{spi} flash \cite[p.4]{lattice2016}.

Despite this check, the \gls{fpga} considers its \gls{gpio} power rail to be stable once it is somewhere between \SI{0.7}{\volt} and \SI{1.59}{\volt} \cite[p.3-2]{lattice2017a}. This means that as the supply voltage slowly ramps up, the \SI{1.2}{\volt} core voltage will be stable, and the \SI{3.3}{\volt} \gls{gpio} supply voltage will be within the range the \gls{fpga} considers stable long before it is close to \SI{3.3}{\volt}. Therefore the \gls{fpga} will start configuration long before the \SI{3.3}{\volt} is high enough to power the \gls{spi} flash \gls{ic} correctly.

Further consultation with the programming and configuration guide reveals that the \gls{fpga} has a pin, named \texttt{CRESET\_B} which can be held low to inhibit the configuration of the \gls{fpga}, and the \gls{fpga} will not configure itself until the signal is asserted \cite[p.4]{lattice2016}. As supplied this pin is held high on the development board with a \SI{10}{\kilo\ohm} resistor.

Inspection of the datasheet of the \gls{ldo} regulator which provides the \SI{3.3}{\volt} and \SI{1.2}{\volt} rails reveals that it provides two pins, named \texttt{PWRGD1} and \texttt{PWRGD2} to indicate when the output is within 10\% of the nominal output voltage \cite[p.11]{linear2013}. This is an open collector output which is high impedance when the power is below 90\% of the nominal value and sinks current when the power output is above this. The output can sink a maximum current of \SI{100}{\micro\ampere}, and is pulled up with a \SI{1}{\mega\ohm} resistor on the development board.

The obvious solution is therefore to remove the pull-down from \texttt{CRESET\_B}, and connect the pin to \texttt{PWRGD1}, the \texttt{PWRGD} output corresponding with the \SI{3.3}{\volt} output, but there is a subtle problem with this approach. Lattice specify that \texttt{CRESET\_B} must be either pulled with a maximum resistance of \SI{10}{\kilo\ohm}, or actively driven \cite[p4-1]{lattice2017a}. Using a \SI{10}{\kilo\ohm} pull-up resistor would however require \texttt{PWRGD1} to sink $I=\frac{\SI{3.3}{\volt}}{\SI{10}{\kilo\ohm}}= \SI{330}{\micro\ampere}$, far more than it is capable of sinking.

The devised solution is that of Figure \ref{fig:fpga-reset-sol}. In this schematic the \SI{1}{\mega\ohm} pull-up resistor on \texttt{PWRGD1} is replaced with a \SI{50}{\kilo\ohm} resistor to provide a strong enough current for the Schmitt buffer, whilst not exceeding the \SI{100}{\micro\ampere} sinking limit of the \gls{ldo} regulator. The output of this Schmitt buffer then drives \texttt{CRESET\_B}, which is pulled down with a \SI{10}{\kilo\ohm} resistor in case the \gls{fpga} detects that its power input are at the correct levels before the buffer \gls{ic} has powered up.


\begin{figure}[ht]
	\centering
	\begin{tikzpicture}
	
	\draw (0,0.35) 

	to[short] ++(0,1.65)

	node[vcc] {3V3};
	
	\draw (0,-0.35) 

	to[short] ++(0,-1.65)

	node[ground] {};	
	
	\draw (0,0) node[buffer] (buf) {}
	(buf.in)  to[short] ++(-1,0) coordinate (pwrgd_pull) to[short] ++(-1,0) coordinate (start);
	\node (pwrgd) [rectangle, draw, minimum size=1cm, anchor=east] at (start) {\texttt{PWRGD1}};
	
	\draw (pwrgd_pull)
	
	to[R, l^=50k] ++(0,2)
	
	node[vcc] {3V3};
	
	\draw (buf.out)
	
	to[short] ++(1,0)
	
	coordinate(pulldown)
	
	to[R, l^=10k] ++(0,-2)

 	node[ground] {};
 	
 	\draw (pulldown)
 
 	to[short] ++(1,0)
 	
 	node (reset) [rectangle, draw, minimum size=1cm, anchor=west] {\texttt{CRESET\_B}};
	
	\end{tikzpicture}
	\caption{\glsentryshort{fpga} reset issue solution}
	\label{fig:fpga-reset-sol}
\end{figure}


\subsection{Signal Breakthrough} \label{sec:signal-breakthrough}
Breakthrough of the input signal to the output has been the most difficult problem encountered during integration of the subsystems. Figure \ref{fig:fpga-initial-input-couping} demonstrates the problem and is a capture of the output of the system as initially integrated. The yellow trace in the oscilloscope capture is the input to the delay line, and the green trace is the output. The larger right hand pulse on the output trace represents the correct output of the delay line, however the left hand pulse should not be present, and is a result of the input coupling to the output. It is approximately \SI{200}{\milli\volt} in amplitude peak to peak. This capture was taken with the oscilloscope connected directly to the output of the amplifier, but the same behaviour occurred with the circuit inside the tube, and the coaxial output was probed.

One point of note is that for all of the traces captured in this section, the standard oscilloscope probe hood and ground clip were removed and a small spring clip was added to provide the probe with a local ground reference. The reason for this probing setup is that a standard length ground lead was able to pick up as much as \SI{500}{\milli\volt} of the input signal, by acting as an antenna when not connected to the circuit.

\begin{figure}[ht]
	\centering
	\includegraphicssized{integration/scope_10}
	\caption{Initial input coupling at \gls{fpga} output}
	\label{fig:fpga-initial-input-couping}
\end{figure}

The initial step to attempt to solve this issue was to implement the input circuitry, which was originally part of the central board assembly, separately and add the metal ring visible on the right hand side of Figure \ref{fig:delay-line-assy}. When assembled, the ring will be connected to the, earthed, metal tube and shield the output circuitry from the input. These modifications improved the performance, approximately halving the amplitude of noise which was coupled onto the output, but the problem still persisted.

\begin{figure}[ht]
	\centering
	\begin{tikzpicture}
	
	\draw (0,0) 
	
	node (in) [rectangle, draw, minimum size=1cm, anchor=east] {Input}
	
	to[pR, l_=4k7, n=POT] ++(2,0);
	
	\draw ([xshift=1cm] POT.east) |- (POT.wiper);
	
	\draw ([xshift=1cm] POT.east) to [C, l^=10n] ++(2,0)
	to [short] ++(1,0)
	coordinate (resistor)
	to [short] ++(1,0)
	node (out) [rectangle, draw, minimum size=1cm, anchor=west] {Output};
	
	\draw (resistor) to[R, l^=68] ++(0,-2) node[ground] {};
	\end{tikzpicture}
	\caption{The passive attenuation circuit used}
	\label{fig:output-passive-attenuator}
\end{figure}

The eventual solution was to remove the output amplifier and instead use a passive attenuation circuit on the \gls{fpga} output. Figure \ref{fig:output-passive-attenuator} shows the schematic for this circuit. The \SI{4.7}{\kilo\ohm} potentiometer and \SI{68}{\ohm} resistor act as a potential divider to attenuate the signal, whilst the \SI{10}{\nano\farad} capacitor removes \gls{dc} bias from the signal to centre it about \SI{0}{\volt}, this circuit was built on a small piece of matrix board mounted at the output coaxial connector, as far as possible from the rest of the circuitry.

This passive attenuation circuit performs well, and a screenshot of its performance is presented in Figure \ref{fig:final-breakthrough}. In this figure the test harness has been modified to not regenerate pulses, and to output a pulse with a fixed different to that of the delay line. This makes it easy to see where the input couples onto the output. As is evident from the screenshot, any coupling of the input to the output is below the noise floor of the oscilloscope. It should be noted that the second channel of the oscilloscope is \SI{50}{\ohm} terminated because in this instance the delay line was assembled, and the output coaxial connector was directly probing the output instead of the output connecting to the amplifier circuit. \SI{50}{\ohm} termination was therefore added to the oscilloscope to approximately match the \SI{70}{\ohm} characteristic impedance of the transmission line.

\begin{figure}[ht]
	\centering
	\includegraphicssized{integration/final_breakthrough_grab}
	\caption{Results of passive attenuation circuit}
	\label{fig:final-breakthrough}
\end{figure}

\chapter{\chapterStyle{Project Planning}} \label{sec:project-planning}
Good planning was essential for the conduction of this project, due to the tight time frame, as well as the scale of the project. This chapter briefly details how the project was planned in terms of both the time allocated to each task, as well as the analysis of risks relating to the project.


\section{Time Management}

Time management was critical in this project due to the fact that the project is quite broad, involving the implementation of two separate systems, the delay line itself and the test harness, which involve work across several different disciplines including: software design, analogue electronics design, and \gls{pld} design.

Appendix \ref{app:proj-plan-charts} contains the charts used to plan how time would be spent on various activities during the project. The first chart included is Figure \ref{fig:pert-chart} which is a \gls{pert} chart produced for the project plan \cite[p.3]{tyler2017b}. In contrast to this the Gantt chart of Figure \ref{fig:gantt-chart} is a record of how time was actually spent on the project.

There are two reasons why the charts are difficult to compare. Firstly the \gls{pert} chart assumed that the design and testing of each sub-system would be followed by a \gls{pcb} implementation of the system, whereas in reality the final system was implemented using matrix board as discussed in Chapter \ref{sec:sys-integration}. In addition, the \gls{pert} chart schedules time at the start of the project for a literature review. In reality, much of the background research was conducted during the writing of the research review, negating some of the need for the literature review \cite{tyler2017}. It was therefore easier to begin planning the implementation of each module, and research any of the finer points of the original design as necessary. It should also be noted that the plan breaks the project into three modules: the delay line itself; the test harness, which is used to mean the digital part of the test harness; and an amplifier module, which is used to refer to the analogue parts of the test harness. For simplicity the final design combines the test harness and amplifier modules.

In order to compare the two plans it is therefore simplest to break the project into two phases. The first phase is the initial design phase, which includes design of each module, research of any of the finer points of the original design as may be necessary, and testing of the design. The second phase is the final implementation of the design, as well as creation of the formal documentation.

Inspection of the \gls{pert} chart shows that it schedules a total of six weeks for this phase. Comparison with the Gantt chart shows that the corresponding stages, all of the work up until the end of the group labelled `Initial Analogue Design', took six weeks and one day. This shows that the project was largely on track up until this point. Unfortunately work could not begin on the second stage at this point, because it was here understood that the phantom power would require further work and investigation than was originally anticipated, as discussed in Chapter \ref{sec:power}, and so a further sixteen days were used to solve this problem.

For phase two, the \gls{pert} chart schedules a total of three weeks for the \gls{pcb} construction and formal documentation to be written. In reality, the corresponding Gantt chart groups, `Building final delay line circuity', and `Documentation' took five weeks. This has taken longer than expected for several reasons. Firstly the project plan only allocates time for a standalone \gls{pcb} implementation. It was not anticipated at the planning stage that the scope of the project would include integration into an actual metal tube. This has required additional construction time, as well as time to debug the issues relating to the signal breakthrough discussed in Section \ref{sec:signal-breakthrough}.

Considering that the unallocated time in the original \gls{pert} chart was intended for changes in scope and unexpected problems, and given that the project was completed successfully achieving all of its goals, it is considered that the time planning in this project has been successful.

\section{Risk Management}

In order to ensure that the project was able to deliver on its intentions, risk analysis was used. The aim of this exercise is to identify the main risks that would impact on the ability of the project to deliver against all of its goals. For each risk, the chance of occurrence, and impact are assessed as well as any mitigation efforts as necessary. Table \ref{tbl:risk-matrix} shows the risk matrix used by this project. A severe impact is an impact that would cause the project to not deliver some or all of its goals. A moderate impact is an impact that would cause the project to not deliver one goal, or cause undesirable performance despite achieving goals. A minor impact is an impact which would cause undesirable performance of the project whilst meeting all goals, and a negligible impact has no measurable impact upon the project.


\newcommand{\riskCellWidth}{2cm}
\newcommand{\riskCellheight}{1cm}
\newcommand{\badCol}{\cellcolor{red!50}} %\cellcolor{green!50}
\newcommand{\midCol}{\cellcolor{yellow!50}}
\newcommand{\goodCol}{\cellcolor{green!50}}
\begin{table}[ht]
	\centering
	\caption{Risk Matrix} \label{tbl:risk-matrix}
	\begin{tabular}{|c|c|p{\riskCellWidth}|p{\riskCellWidth}|p{\riskCellWidth}|p{\riskCellWidth}|}
		\cline{3-6}
		\multicolumn{2}{c|}{} &  \multicolumn{4}{c|}{Impact}\\
		\cline{3-6}
		\multicolumn{2}{c|}{} & Negligible & Minor & Moderate & Severe \\
		\hline
		\multirow{4}{*}[-1cm]{\rotatebox[origin=c]{90}{Chance of Occurrence}} & Very Unlikely & \goodCol &\goodCol &\goodCol & \midCol  \\ [\riskCellheight]
		\hhline{|~|-----}
		& Unlikely & \goodCol &\goodCol &\midCol & \badCol  \\ [\riskCellheight]
		\hhline{|~|-----}
		& Likely & \goodCol &\midCol &\badCol & \badCol  \\ [\riskCellheight]
		\hhline{|~|-----}
		& Very Likely & \midCol &\badCol &\badCol & \badCol \\ [\riskCellheight]
		\hline
	\end{tabular}
\end{table}

\begin{table}[ht]
	
	
	\centering

	\caption{Project Risks}
	\label{tbl:risks}
	\begin{tabular}{p{0.2\textwidth} p{0.1\textwidth} p{0.1\textwidth} p{0.3\textwidth} p{0.1\textwidth}}
		
		\toprule
		Risk & Estimated Likelihood and Impact & Risk Rating & Risk Controls & Treated Risk Rating \\

		\midrule
		
		Modules will work independently, but not together & Unlikely, Severe & \badCol &
		\begin{enumerate}
			\item Comprehensive test harness GUI to allow easy debug.
			\item Integration both before and after analogue circuit design
		\end{enumerate} 
		& \midCol \\
		
		
		The design will work in development, but the final design will not have the correct performance & Likely, Moderate & \badCol &
		\begin{enumerate}
			\item The final design is be implemented on matrix board, not using a custom \gls{pcb} for greater reconfigurability.
			\item Slack time was available at the end of the project to debug issues with the final design
		\end{enumerate} 
		& \goodCol \\
		
				
		The design will work using the testbench, but will require further work to integrate with \gls{edsac} & Very Likely, Moderate & \badCol &
		\begin{enumerate}
			\item The testbench is comprehensive to identify problems before integration.
			\item \gls{spice} simulation was performed with valve models to ensure the analogue part of the design will work with \gls{edsac}
		\end{enumerate} 
		& \midCol \\

		\bottomrule
		
	\end{tabular}
	
\end{table}


\chapter{\chapterStyle{Final Comments}} \label{sec:conclusion}

The aim of this project was to create a delay line capable of forming the store of \gls{edsac}, without requiring excessive modification to the rest of \gls{edsac}, and without deviating from the physical appearance of the original. This has been achieved in full, with this report presenting methodology to both achieve the delay, and emulate the driving signals of \gls{edsac}. The circuitry required for the delay unit fits inside of the footprint of the original storage tubes and only requires the addition of a single \SI{1}{\milli\henry} inductor, per delay line installed, in order to power the store.

In addition to the delay line itself, a comprehensive test harness has been created which is capable of driving each delay line, receiving and regenerating the returned pulses, and detecting any errors in the output of the delay line. This is suitable for testing the performance of each delay line without integration with \gls{edsac}.

Due to difficulties with testing the design with the physical \gls{edsac} reconstruction machine, notably the physical machine being located far from Southampton and the incomplete nature of the machine, extensive \gls{spice} simulations were performed to ensure that the delay line would integrate well with the relevant components of \gls{edsac}. These simulations were successful and showed that the delay line was able to integrate well with the store regeneration chassis in all respects.

Following the successful construction and testing of the delay line, it was taken to \gls{tnmoc} to integrate with the rest of the machine. The integration effort was successful and the delay line was powered from the valve chassis, accepted the pulses sent to it, and transmitted pulses back to the chassis after the required delay. These pulses were correctly amplified and demodulated. The only problem encountered was an issue with the valve chassis not correctly regenerating the pulses. It was ambiguous as to whether this is a problem with the delay line or the chassis itself however, as there had not previously been any method to test this particular chassis with a delay medium.

There is some scope for further development on this project, notably to continue integration with the rest of the system, and there is also scope to produce the design more formally using a \gls{pcb} now that the concept is proven. This is work which is intended to take place, with the intention that the delay line will be able to form some part of the final \gls{edsac} exhibit and help to educate the general public about the history of computing.

